# 编码原则
本章介绍编码原则。 提出了以下原则：

- 统一变量命名原则
- 统一源代码仓库结构原则
- 源代码目录树结构原则
- 避免注释原则
- 函数单return语句原则
- 偏好静态类型语言原则
- 重构原则
- 静态代码分析原则
- 错误/异常处理原则
- 不要传递或返回 null 原则
- 避免差一错误原则
- 谷歌搜索原则时要批判
- 优化原则

## 统一变量命名原则

> 一个好的变量名应该描述变量的用途和类型。

最好的情况是，用好名字编写代码会让它读起来像散文一样。 请记住，阅读代码的次数多于编写代码的次数，因此代码必须易于阅读和理解。

使用同时传达有关变量类型信息的名称命名变量在非类型化语言中至关重要，在类型化语言中也是有益的，因为现代类型化语言使用自动类型推导，并且你不会总是看到变量的实际类型。 但是当变量的名称告诉它的类型时，类型名称是否可见并不重要。

在以下部分中，提出了不同类型变量的命名约定。

### 命名整数变量

有些变量本质上是整数，例如年龄或年份。 每个人都会立即明白年龄或年份变量的类型是数字，更具体地说，是整数。 因此，你不必在变量名称中添加任何内容来指示其类型。 它已经告诉你它的类型。

最常用的整数变量类别之一是某物的计数或数量。 你会在每段代码中看到这些类型的变量。 我建议使用以下约定来命名这些变量：```numberOf<something>``` 或 ```<something>Count```。 例如，```numberOfFailures``` 或 ```failureCount```。 你不应使用变量名 ```failures``` 来指定失败计数。 该变量名的问题是它没有明确指定变量的类型，因此可能会造成一些混淆。 这是因为名为 ```failures``` 的变量可能会被误解为集合变量（例如，失败列表）。

如果一个变量的单位不是不言自明的，总是在变量名的末尾添加关于单位的信息。 例如，你不应将变量命名为 ```tooltipShowDelay```，而应将其命名为 ```tooltipShowDelayInMillis``` 或 ```tooltipShowDelayInMillisecs```。 如果你有一个单位不言自明的变量，则不需要单位信息。 因此，无需将年龄变量命名为 ```ageInYears```。 但是，如果你以月为单位测量年龄，则必须将相应的变量命名为 ```ageInMonths```，这样人们就不会认为年龄是以年为单位的。

### 命名浮点数变量

浮点数不像整数那么常见，但有时你也需要它们。 有些值本质上是浮点数，就像大多数未舍入的度量（例如，价格、高度、宽度或重量）。 如果你需要存储测量值，那么使用浮点变量是一个安全的选择。

如果你需要存储一定数量的非整数值，请使用名为 ```<something>Amount``` 的变量，例如 ```rainfallAmount```。 当你在代码中看到"某物的数量"时，你会不自觉地认为它是一个浮点数。 如果你需要在算术中使用数字，根据应用程序，你可能希望使用浮点数或整数算术。 就金钱而言，你应该使用整数运算来避免舍入误差。 代替浮点 ```moneyAmount``` 变量，你应该有一个整型变量，例如 ```moneyInCents```。

如果变量的单位不明确，请在变量名称末尾添加有关单位的信息，例如 ```rainfallAmountInMillimeters```、```widthInInches```、```angleInDegrees```（值 ```0-360```）、```failurePercent```（值 ```0-100```）或 ```failureRatio```（值 ```0-1```).

### 命名布尔变量

布尔变量只能有两个值之一：```true``` 或 ```false```。 布尔变量的名称应该形成一个语句，其中答案是真或假，或者是或否。 典型的布尔变量命名模式是：```is<something>```、```has<something>```、```did<something>```、```should<something>```、```_can<something>``` 或 ```will<something>```。 遵循上述模式的变量名称的一些示例是 ```isDisabled```、```hasErrors```、```didUpdate```、```shouldUpdate``` 和 ```willUpdate```。

布尔变量名称中的动词不必位于开头。 如果它能让代码更好读，它可以而且应该在中间。 布尔变量经常用在 if 语句中，其中更改变量名称中的词序可以使代码更好读。 请记住，充其量，代码读起来就像优美的散文，而且阅读的次数多于编写的次数。

下面是一个代码片段，其中我们有一个名为 ```isPoolFull``` 的布尔变量：

```java
if (const bool isPoolFull = m_pooledMessages.size() >= 200U;
      isPoolFull)
{
  // ...
}
else
{
  // ...
}
```

我们可以将变量名更改为 ```poolIsFull``` 以使 ```if``` 语句读起来更流畅。 在下面的示例中，```if``` 语句读取```if pollIsFull```而不是```if isPoolFull```：

```java
if (const bool poolIsFull = m_pooledMessages.size() >= 200U;
      poolIsFull)
{
  // ...
```

不要使用 ```<passive-verb>Something``` 形式的布尔变量名，比如 ```insertedField```，因为这会让读者感到困惑。 不清楚变量名是命名对象的名词还是布尔语句。 相反，使用 ```didInsertField``` 或 ```fieldWasInserted```。

下面是一个用于存储函数返回值的变量的错误命名的 ```Go``` 语言示例。 有人可能认为 ```tablesDropped``` 表示删除的表名列表。 因此，变量的名称是模糊的，应该更改。

```java
tablesDropped := dropRedundantTables(prefix,
                                     vmsdata,
                                     cfg.HiveDatabase,
                                     hiveClient,
                                     logger)
if tablesDropped {
  // ...
}
```

下面是修改后的上述示例，以便更改变量名称以指示布尔语句：

```java
tablesWereDropped := dropRedundantTables(prefix,
                                         vmsdata,
                                         cfg.HiveDatabase,
                                         hiveClient,
                                         logger)
if tablesWereDropped {
  // ...
}
```

你可以使用名为 ```didDropTables``` 的变量，但 ```tablesWereDropped``` 使 ```if``` 语句更具可读性。

### 命名字符串变量

字符串变量很普遍，许多东西本质上都是字符串，例如名称、标题、城市、国家或主题。 当需要在字符串变量中存储数值数据时，明确告诉代码阅读者这是一个关于字符串格式数字的问题，并使用以下格式的变量名：```<someValue>String``` 或```<someValue>AsString```。 它使代码更突出，更容易理解。 例如：

```java
const year = parseInt(yearAsString, 10);
```

### 命名枚举变量
使用与枚举类型相同的名称命名枚举变量。 例如，```CarType``` 枚举变量应命名为 ```carType```。 如果枚举类型的名称非常通用，如 ```Result```，你可能会受益于声明一个枚举变量并在变量名称中添加一些细节。 下面是一个非常通用的枚举类型名称的示例：

```PulsarProducer.cpp```

```c++
// Returns enum type 'Result'
const auto result = pulsar::createProducer(...); 

if (result == Result.Ok) {
  // ...
}
```

让我们向结果变量名称添加一些细节和上下文：

```PulsarProducer.cpp```

```c++
const auto producerCreationResult = pulsar::createProducer(...);

if (producerCreationResult == Result.Ok) {
  // ...
}
```

### 命名集合（数组、列表和集合）变量

在命名数组、列表和集合时，你应该使用名词的复数形式，例如 ```customers```、```errors``` 或 ```tasks```。 在大多数情况下，这就足够了，因为你不一定需要了解底层的集合实现。 使用此命名约定允许你更改集合变量的类型而无需更改变量名称。 如果你正在遍历一个集合，那么它是数组、列表还是集合都没有关系。 因此，如果你将集合类型名称添加到变量名称中，例如 ```customerList``` 或 ```taskSet```，则不会带来任何好处。 这些名字只是更长。 在某些特殊情况下，你可能希望指定集合类型。 然后，你可以使用以下类型的变量名称：```queueOfTasks```、```stackOfCards``` 或 ```orderedSetOfTimestamps```。

下面是一个 ```Go``` 语言的例子，其中函数被正确命名为返回一个（类别的）集合，但是接收返回值的变量没有按照集合变量命名约定命名：

```go
vmsdata, error = vmsClient.GetCategories(vmsUrl, logger)
```

正确的命名是：

```go
vmsCategories, error = vmsClient.GetCategories(vmsUrl, logger)
```

### 命名映射变量

通过请求某个键的值来访问地图。 这就是为什么我建议使用模式 ```keyToValueMap``` 命名映射。 假设我们有一张地图，其中包含客户 ```ID``` 的订单计数。 该映射应命名为 ```customerIdToOrderCountMap```。 或者，如果我们有产品名称的供应商列表，则映射变量应命名为 ```productNameToSuppliersMap```。 下面是在 ```Java``` 中访问地图的示例：

```java
final var orderCount = customerIdToOrderCountMap.get(customerId);
final var suppliers = productNameToSuppliersMap.get(productName);
```

下面是一个在 ```JavaScript``` 中遍历地图的例子：

```javascript
Object.entries(customerIdToOrderCountMap)
      .map(([customerId, orderCount]) => ...);
```

### 命名对和元组变量

包含一对的变量应使用模式 ```variable1AndVariable2``` 命名。 例如：高度和宽度。 对于元组，推荐的命名模式是 ```variable1Variable2…andVariableN```。 例如：高度宽度和深度。

下面是在 ```JavaScript``` 中使用对和元组的示例：

```javascript
const heightAndWidth = [100, 200];
const heightWidthAndDepth = [100, 200, 40];
const [height, , depth] = heightWidthAndDepth;
```

### 命名对象变量

对象变量指的是类的实例。 类名是首字母大写的名词，例如 ```Person```、```Account``` 或 ```Task```。 对象变量名应该包含相关的类名：```Person```类的```person```对象，```Account```类的```account```对象等。你可以随意修饰对象的名字，比如用形容词：```completedTask```。 重要的是在变量名的末尾包含类名或至少其中的一些重要部分。 然后查看变量名的末尾可以知道所讨论的对象类型。

有时你可能想命名一个对象变量，使其类的名称是隐式的，例如：

```java
// The class of the function parameters, 'Location', is implicit
drive(home, destination);
```

在上面的示例中，```home``` 和 ```destination``` 对象的类不是显式的。 在大多数情况下，在不使变量名太长的情况下，最好在变量名中明确显示类名。 这是因为变量类型推导。 变量的类型不一定在代码中可见，因此变量的类型应该通过变量名来传达。 下面是一个示例，其中函数参数的类型是明确的。

```java
// The class of the function parameters, 'Location', is now explicit
drive(homeLocation, destLocation);
```

### 命名可选变量

如何命名可选变量取决于编程语言和可选类型的实现方式。 在需要从可选对象中解包可能值的语言中，可选变量名称应以 maybe 为前缀。

在 ```Java``` 中，当使用 ```Optional<T>``` 时，使用以下模式命名此类型的变量：```maybe<Something>```：

```java
maybeLoggedInUser.ifPresent(loggedInUser -> loggedInUser.logout());
final User currentUser = maybeLoggedInUser.orElse(guestUser);
```

在 ```TypeScript``` 和其他使用类型联合创建可选类型的语言中，你不需要在可选变量名称中添加任何前缀。 在下面的例子中，```discount``` 参数是可选的，它的类型是 ```number``` | 不明确的：

```javascript
function addTax(
  price: number,
  discount?: number
): number {
  return 1.2 * (price — (discount ?? 0));
}

const priceWithTax = addTax(priceWithoutTax);
```

### 命名函数变量（回调）

回调函数是提供给其他函数的函数，以便在某个时候调用。 如果回调函数有返回值，可以根据返回值命名，但仍应包含动词。 如果回调函数没有返回值，你应该像命名任何其他函数一样为回调函数命名：表明函数的作用。 假设你有一个存储函数对象的变量，例如 ```Java Function``` 实例。 在这种情况下，你需要根据对象变量的规则来命名变量，即变量名应该是名词。 例如，如果你有一个当前名为 ```map``` 的 ```Java Function``` 对象，你应该将名称更正为名词，如 ```mapper```。

```java
const doubledValue = value => 2 * value;
const squaredValue = value => value * value;
const valueIsEven = nbr => (nbr % 2) === 0;
const values = [1, 2, 3, 4, 5]
const doubledValues = values.map(doubledValue);
const squaredValues = values.map(squaredValue);
const evenValues = values.filter(valueIsEven);

const strings = [" string1", "string2 "];
const trimmedString = str => str.trim();
const trimmedStrings = strings.map(trimmedString);

const sumOfValues = (sum, value) => sum + value;
values.reduce(sumOfValues, 0);
```

如果将 ```map``` 函数重命名为 ```mapEach``` 并将 ```reduce``` 函数重命名为 ```reduceTo```，则上面的示例会更加明显：

```java
const doubledValues = values.mapEach(doubledValue);
const trimmedStrings = strings.mapEach(trimmedString);
values.reduceTo(sumOfValues, 0);
```

让我们举一个用 ```Clojure``` 编写的示例：

```clojure
(defn print-first-n-doubled-integers [n]
  (println (take n (map (fn [x] (* 2 x)) (range)))))
```

要了解上面代码中发生的情况，你应该从最内层的函数调用开始阅读，然后继续阅读最外层的函数调用。 在遍历函数调用层次结构时，难点在于在短期记忆中存储和保留有关所有嵌套函数调用的信息。

我们可以通过为匿名函数命名并为中间函数调用结果引入变量（常量）来简化上面示例的阅读。 当然，我们的代码变得更冗长，但编码不是写最短代码的竞赛，而是为其他人和你未来的自己编写最短、最易读、最易理解的代码。 编译器的工作是将下面较长的代码编译成与上面较短的代码一样高效的代码。

下面是上面重构的代码：

```clojure
(defn print-first-n-doubled-integers [n]
  (let [doubled (fn [x] (* 2 x))
        doubled-integers (map doubled (range))
        first-n-doubled-integers (take n doubled-integers)]
          (println first-n-doubled-integers)))
```

让我们假设一下：如果 ```Clojure``` 的 ```map``` 函数以不同的顺序获取参数并且 ```range``` 函数被命名为 ```integers``` 而 ```take``` 函数被命名为 ```take-first```（就像 ```take-las```t），我们将得到原始代码的更明确的版本：

```clojure
(defn print-first-n-doubled-integers [n]
  (let [doubled (fn [x] (* 2 x))
        doubled-integers (map (integers) doubled)
        first-n-doubled-integers (take-first n doubled-integers)]
          (println first-n-doubled-integers)))
```

### 命名类属性

类属性（即类属性、字段或成员变量）的命名应避免在属性名称中重复类名。 下面是一个错误命名的例子：

```java
public class Order {
  private long orderId;
  private OrderState orderState;
}
```

以下是带有更正名称的上述代码：

```java
public class Order {
  private long id;
  private OrderState state;
}
```

如果你有一个类属性来存储回调函数（例如，事件处理程序或生命周期回调），你应该给它命名，以便它告诉在什么情况下调用存储的回调函数。 使用以下模式命名存储事件处理程序的属性：```on + <event-type>```，例如 ```onClick``` 或 ```onSubmit```。 以类似于命名生命周期方法的方式命名存储生命周期回调的属性，例如：```onInit```、```afterMount``` 或 ```beforeMount```。

### 一般命名规则
#### 使用简短的通用名称

为某物取名时，请使用最常见的最短名称。 如果你有一个名为 ```relinquishSomething``` 的函数，请考虑为该函数取一个更短、更常用的名称。 例如，你可以将该函数重命名为 ```releaseSomething```。```release```这个词比```relinquish```这个词更短也更常见。 使用谷歌搜索单词同义词，例如```relinquish synonym```，以找到最短和最常见的相似词。

#### 选择一个名字并始终如一地使用它

假设你正在构建一个数据导出器微服务，并且你当前在代码中使用以下术语：消息、报告、记录和数据。 与其使用四个不同的术语来描述同一事物，不如只选择一个术语，例如消息，并在整个微服务代码中始终如一地使用它。

假设你需要找出一个术语来表示一个类的属性。 你应该只选择一个术语，比如财产，并在任何地方始终如一地使用它。 你不应使用多个术语（如属性、字段和成员）来描述类的属性。

#### 避免晦涩的缩写

许多缩写是常用的，例如字符串的 ```str```、数字的 ```num/nbr```、属性的 ```prop``` 或值的 ```val```。 大多数程序员使用这些，我用它们来缩短长名称。 如果变量名很短，则应使用全名，如 ```numberOfItems``` 而不是 ```nbrOfItems```。 在变量名称变得太长的情况下使用缩写。 我特别要避免的是使用不常见的缩写。 例如，我永远不会将 ```amount``` 缩写为 ```amnt``` 或将 ```discount``` 缩写为 ```dscnt```，因为我没有看到这些缩写在现实生活中被广泛使用。

#### 避免太短或无意义的名字

太短的名称无法传达变量的含义。 作为循环计数器，如果循环变量用于索引某些东西，例如数组，请使用像 ```index``` 或 ```<something>Index``` 这样的变量名。 索引变量应从零开始。 如果循环变量正在计算事物的数量，请使用 ```number``` 或 ```_<something>Number``` 作为变量名，并从值 ```1``` 而不是 ```0``` 开始循环计数器。 例如，启动五个线程的循环应按以下方式用 ```C++``` 编写：

```c++
for (size_t threadNumber{1U}; threadNumber <= 5U; ++threadNumber)
{
  startThread(threadNumber);
}
```

如果你不需要在循环内部使用循环计数器值，你可以使用一个名为 ```count``` 的循环变量：

```c++
for (size_t count{1U}; count <= objectCount; ++count)
{
  objects.push_back(acquireObject(std::forward<Args>(args)...));
}
```

## 统一源代码库结构原则
以某种方式系统地构建源代码存储库中的代码，使其他开发人员可以轻松快速地发现所需信息。

下面是为 ```Java```、```C++``` 和 ```JavaScript/TypeScript``` 微服务构建源代码存储库的方法示例。 在下面的示例中，假定部署到 ```Kubernetes``` 集群的容器化 (```Docker```) 微服务。 你的 ```CI``` 工具可能要求 ```CI/CD``` 管道代码必须位于特定目录中。 但如果没有，请将 ```CI/CD``` 管道代码放在 ```ci-cd``` 目录中。

### ```Java``` 源代码存储库结构

下面是建议的 ```Java``` 微服务源代码存储库结构（使用 ```Gradle``` 构建工具）：

```
java-service
├── ci-cd
│   └── Jenkinsfile
├── docker
│   ├── Dockerfile
│   └── docker-compose.yml
├── docs
├── env
│   ├── .env.dev
│   └── .env.ci
├── gradle
│   └── wrapper
│       └── ...
├── helm
│   └── java-service
│       ├── templates
│       ├── .helmignore
│       ├── Chart.yaml
│       ├── values.schema.json
│       └── values.yaml
├── integration-tests
│   ├── features
│   │   └── feature1.feature
│   └── steps
├── scripts
│   └── // Bash scripts here...
├── src
│   ├── main
│   │   ├── java
│   │   │   └── com.domain.java-service
│   │   │       └── // source code
│   │   └── resources
│   └── test
│       ├── java
│       │   └── com.domain.java-service
│       │       └── // unit test code
│       └── resources
├── .gitignore
├── build.gradle
├── gradlew
├── gradlew.bat
├── README.MD
└── settings.gradle
```

### ```C++``` 源代码存储库结构

下面是建议的 ```C++``` 微服务源代码存储库结构（使用 ```CMake``` 构建工具）：

```
cpp-service
├── ci-cd
│   └── Jenkinsfile
├── docker
│   ├── Dockerfile
│   └── docker-compose.yml
├── docs
├── env
│   ├── .env.dev
│   └── .env.ci
├── helm
│   └── cpp-service
│       ├── templates
│       ├── .helmignore
│       ├── Chart.yaml
│       ├── values.schema.json
│       └── values.yaml
├── integration-tests
│   ├── features
│   │   └── feature1.feature
│   └── steps
├── scripts
│   └── // Bash scripts here...
├── src
│   ├── // source code here
│   │   main.cpp
│   └── CMakeLists.txt
├── test
│   ├── // unit test code
│   │   main.cpp
│   └── CMakeLists.txt
├── .gitignore
├── CMakeLists.txt
└── README.MD
```

### ```JavaScript/TypeScript``` 源代码存储库结构
下面是建议的 ```JavaScript/TypeScript``` 微服务源代码存储库结构：

```
ts-service
├── ci-cd
│   └── Jenkinsfile
├── docker
│   ├── Dockerfile
│   └── docker-compose.yml
├── docs
├── env
│   ├── .env.dev
│   └── .env.ci
├── helm
│   └── ts-service
│       ├── templates
│       ├── .helmignore
│       ├── Chart.yaml
│       ├── values.schema.json
│       └── values.yaml
├── integration-tests
│   ├── features
│   │   └── feature1.feature
│   └── steps
├── scripts
│   └── // Bash scripts here...
├── src
│   └── // source code here
├── test
│   └── // unit test code here 
├── .gitignore
├── .eslintrc.json
├── .prettier.rc
├── package.json
├── package-lock.json
├── README.MD
└── tsconfig.json
```

## 基于域的源代码结构原则
主要按领域而不是技术细节来构建源代码树。 每个源代码目录在其抽象级别上都应该有单一的职责。

下面是一个 ```Spring Boot``` 微服务的 ```src``` 目录示例，该目录未按域组织，但根据技术细节组织不正确：

```
spring-example-service/
└── src/
    └── java/
        └── com.silensoft.springexampleservice/
            ├── controllers/
            │   ├── AController.java
            │   └── BController.java
            ├── entities/
            │   ├── AEntity.java
            │   └── BEntity.java
            ├── errors/
            │   ├── AError.java
            │   └── BError.java
            ├── dtos/
            │   ├── ADto.java
            │   └── BDto.java
            ├── repositories/
            │   ├── ARepository.java
            │   └── BRepository.java
            └── services/
                ├── AService.java
                └── BService.java
```

以下是修改后的上述示例，目录按域组织：

```
spring-example-service/
└── src/
    └── java/
        └── com.silensoft.springexampleservice/
            ├── domainA/
            │   ├── AController.java
            │   ├── ADto.java
            │   ├── AEntity.java
            │   ├── AError.java
            │   ├── ARepository.java
            │   └── AService.java
            └── domainB/
                ├── BController.java
                ├── BDto.java
                ├── BEntity.java
                ├── BError.java
                ├── BRepository.java
                └── BService.java
```

你可以有多个级别的嵌套域：

```
spring-example-service/
└── src/
    └── java/
        └── com.silensoft.springexampleservice/
            ├── domainA/
            │   ├── domainA-1/
            │   │   ├── A1Controller.java
            │   │   └── ...
            │   └── domainA-2/
            │       ├── A2Controller.java
            │       └── ...
            └── domainB/
                └── BController.java
```

如果需要，你可以在域目录中为技术细节创建子目录。 这是推荐的方法，否则域目录将包含超过 5 到 7 个文件。 以下是 ```salesitem``` 域的示例：

```
sales-item-service
└── src
    └── java
        └── com.silensoft.salesitemservice
            └── salesitem
                ├── dtos
                │   ├── SalesItemArg.java
                │   └── SalesItemResponse.java
                ├── entities
                │   └── SalesItem.java
                ├── errors
                │   └── SalesItemRelatedError.java
                │   └── SalesItemRelatedError2.java
                ├── repository
                │   └── SalesItemRepository.java
                ├── service
                │   ├── SalesItemService.java
                │   └── SalesItemServiceImpl.java
                └── SalesItemController.java
```

下面是上一章设计的数据导出器微服务的源码目录结构。 有四个子域的子目录：输入、内部消息、转换器和输出。 在类名中为每个共同提名人创建了一个子目录。 定位特定文件时，可以毫不费力地浏览目录树。 此外，每个目录中的源代码文件数量很少。 一眼就能掌握目录的内容。 包含很多文件的目录的问题是不容易找到想要的文件。 因此，理想情况下，一个目录应该有 2-4 个文件。 绝对最大值为 5-7 个文件。

请注意，下面有几个目录未展开以缩短示例。 读者应该很容易推断出未展开目录的内容。

```
src
├── common
├── input
│   ├── config
│   │   ├── parser
│   │   │   ├── json
│   │   │   │   ├── JsonInputConfigParser.cpp
│   │   │   │   └── JsonInputConfigParser.h
│   │   │   └── InputConfigParser.h
│   │   ├── reader
│   │   │   ├── localfilesystem
│   │   │   │   ├── LocalFileSystemInputConfigReader.cpp
│   │   │   │   └── LocalFileSystemInputConfigReader.h
│   │   │   └── InputConfigReader.h
│   │   ├── InputConfig.h
│   │   ├── InputConfigImpl.cpp
│   │   └── InputConfigImpl.h
│   │
│   └── message
│       ├── consumer
│       │   ├── kafka
│       │   │   ├── KafkaInputMessageConsumer.cpp
│       │   │   └── KafkaInputMessageConsumer.h
│       │   └── InputMessageConsumer.h
│       ├── decoder
│       │   ├── avrobinary
│       │   │   ├── AvroBinaryInputMessageDecoder.cpp
│       │   │   └── AvroBinaryInputMessageDecoder.h
│       │   └── InputMessageDecoder.h
│       ├── kafka
│       │   ├── KafkaInputMessage.cpp
│       │   └── KafkaInputMessage.h
│       │
│       └── InputMessage.h
├── internalmessage
    ├── field
│   ├── InternalMessage.h
│   ├── InternalMessageImpl.cpp
│   └── InternalMessageImpl.h
├── transformer
│   ├── config
│   │   ├── parser
│   │   ├── reader
│   │   ├── TransformerConfig.h
│   │   ├── TransformerConfigImpl.cpp
│   │   └── TransformerConfigImpl.h
│   ├── field
│   │   ├── copy
│   │   │   ├── CopyFieldTransformer.cpp
│   │   │   └── CopyFieldTransformer.h 
│   │   ├── expression
│   │   ├── filter
│   │   ├── typeconversion
│   │   ├── FieldTransformer.h
│   │   ├── FieldTransformers.h
│   │   ├── FieldTransformaresImpl.cpp
│   │   └── FieldTransformersImpl.h
│   └── message
│       ├── MessageTransformer.h
│       ├── MessageTransformerImpl.cpp
│       └── MessageTransformerImpl.h
└── output
    ├── config
    │   ├── parser
    │   ├── reader
    │   ├── OutputConfig.h
    │   ├── OutputConfigImpl.cpp
    │   └── OutputConfigImpl.h
    └── message
        ├── encoder
        │   ├── avrobinary
        │   └── OutputMessageEncoder.h
        ├── producer
        │   ├── pulsar
        │   └── OutputMessageProducer.h
        ├── OutputMessage.h
        ├── OutputMessageImpl.cpp
        └── OutputMessageImpl.h
```

下面是上述目录结构的 ```Java``` 版本：

```
src
├── common
├── input
│   ├── config
│   │   ├── parser
│   │   │   ├── InputConfigParser.java
│   │   │   └── JsonInputConfigParser.java
│   │   ├── reader
│   │   │   ├── InputConfigReader.java
│   │   │   └── LocalFileSystemInputConfigReader.java
│   │   ├── InputConfig.java
│   │   └── InputConfigImpl.java
│   └── message
│       ├── consumer
│       │   ├── InputMessageConsumer.java
│       │   └── KafkaInputMessageConsumer.java
│       ├── decoder
│       │   ├── InputMessageDecoder.java
│       │   └── AvroBinaryInputMessageDecoder.java
│       ├── InputMessage.java
│       └── KafkaInputMessage.java
├── internalmessage
│   ├── field
│   ├── InternalMessage.java
│   └── InternalMessageImpl.java
├── transformer
│   ├── config
│   ├── field
│   │   ├── impl
│   │   │   ├── CopyFieldTransformer.java
│   │   │   ├── ExpressionFieldTransformer.java
│   │   │   ├── FilterFieldTransformer.java
│   │   │   └── TypeConversionFieldTransformer.java
│   │   ├── FieldTransformer.java
│   │   ├── FieldTransformers.java
│   │   └── FieldTransformersImpl.java
│   └── message
│       ├── MessageTransformer.java
│       └── MessageTransformerImpl.java
└── output
    ├── config
    └── message
```

下面是上一章设计的异常检测微服务的源码目录结构。 异常目录已展开。 我们可以看到我们的实现使用 ```JSON``` 进行各种解析活动，并使用自组织映射 (```SOM```) 进行异常检测。 ```JSON``` 和 ```Kafka``` 用于在微服务外部发布异常指标。 将新的具体实现添加到以下目录结构非常简单。 例如，如果我们想为配置文件添加 ```YAML``` 支持，我们可以创建 ```yaml``` 子目录，我们可以在其中放置特定于 ```YAML``` 的实现类。

```
src
├── anomaly
│   ├── detection
│   │   ├── configuration
│   │   │   ├── parser
│   │   │   │   ├── json
│   │   │   │   │   ├── JsonAnomalyDetectionConfigParser.cpp
│   │   │   │   │   └── JsonAnomalyDetectionConfigParser.h
│   │   │   │   └── AnomalyDetectionConfigParser.h          
│   │   │   ├── AnomalyDetectionConfig.h
│   │   │   ├── AnomalyDetectionConfigFactory.h
│   │   │   ├── AnomalyDetectionConfigFactoryImpl.h
│   │   │   ├── AnomalyDetectionConfigImpl.cpp
│   │   │   └── AnomalyDetectionConfigImpl.h      
│   │   ├── engine
│   │   │   ├── AnomalyDetectionEngine.h
│   │   │   ├── AnomalyDetectionEngineImpl.cpp
│   │   │   └── AnomalyDetectionEngineImpl.h
│   │   ├── rule
│   │   │   ├── parser
│   │   │   │   ├── json
│   │   │   │   │   ├── JsonAnomalyDetectionRuleParser.cpp
│   │   │   │   │   └── JsonAnomalyDetectionRuleParser.h
│   │   │   │   └── AnomalyDetectionRuleParser.h
│   │   │   ├── AnomalyDetectionRule.h
│   │   │   ├── AnomalyDetectionRuleFactory.h
│   │   │   ├── AnomalyDetectionRuleFactoryImpl.h
│   │   │   ├── AnomalyDetectionRuleImpl.cpp
│   │   │   └── AnomalyDetectionRuleImpl.h
│   │   ├── AnomalyDetector.h
│   │   ├── AnomalyDetectorImpl.cpp
│   │   └── AnomalyDetectorImpl.h
│   ├── indicator
│   │   ├── publisher
│   │   │   ├── kafka
│   │   │   │   ├── KafkaAnomalyIndicatorPublisher.cpp
│   │   │   │   └── KafkaAnomalyIndicatorPublisher.h
│   │   │   └── AnomalyIndicatorPublisher
│   │   ├── serializer
│   │   │   ├── json
│   │   │   │   ├── JsonAnomalyIndicatorSerializer.cpp
│   │   │   │   └── JsonAnomalyIndicatorSerializer.h
│   │   │   └── AnomalyIndicatorSerializer.h
│   │   ├── AnomalyIndicator.h
│   │   ├── AnomalyIndicatorFactory.h
│   │   ├── AnomalyIndicatorFactoryImpl.h
│   │   ├── AnomalyIndicatorImpl.cpp
│   │   └── AnomalyIndicatorImpl.h
│   └── model
│       ├── som
│       │   ├── SomAnomalyModel.cpp
│       │   ├── SomAnomalyModel.h
│       │   └── SomAnomalyModelFactory.h
│       ├── training
│       │   ├── engine
│       │   │   ├── AnomalyModelTrainingEngine.h
│       │   │   ├── AnomalyModelTrainingEngineImpl.cpp
│       │   │   └── AnomalyModelTrainingEngineImpl.h
│       │   ├── som
│       │   │   ├── SomAnomalyModelTrainer.cpp
│       │   │   └── SomAnomalyModelTrainer.h
│       │   └── AnomalyModelTrainer.h  
│       ├── AnomalyModel.h
│       └── AnomalyModelFactory.h
├── common
├── measurement
├── Application.h
├── Application.cpp
├── DependencyInjector.h
└── main.cpp
```

让我们再举一个数据可视化网络客户端的例子。

此 ```Web``` 客户端的 ```UI``` 由以下页面组成，所有页面均包含一个公共标题：

- 仪表板
- 数据浏览器
- 警报

仪表板页面包含仪表板组选择器、仪表板选择器和图表区域，用于显示所选仪表板的图表。 你可以通过首先选择一个仪表板组然后从该组中选择一个仪表板来选择显示的仪表板。

![](./images/04/4-1.png)

```Data Explorer``` 页面包含用于选择数据源、度量和维度的选择器。 该页面还包含用于显示图表的图表区域。 使用选择器，用户可以更改图表区域中当前选定图表的显示度量和维度。

![](./images/04/4-2.png)

基于以上设计，Web客户端可以分为以下子域：

- 常用的 UI 组件
  - 图表区
    - 图表
- 标头
- 页面
  - 告警
  - 仪表板
  - 数据浏览器

源代码树应该如下所示：

```
src
├── app
│   ├── common
│   │   └── chartarea
│   │       └── chart
│   ├── header
│   └── pages
│       ├── alerts
│       ├── dashboards
│       │   └── selectors
│       │       ├── dashboardgroup
│       │       └── dashboard
│       └── dataexplorer
│           └── selectors
│               ├── datasource
│               ├── dimension
│               └── measure
├── index.ts
└── store.ts
```

以下是使用 ```React```、```Redux``` 和 ```SCSS``` 模块时单个子域目录的示例：

```
src
├── app
│   └── header
│       ├── model
│       │   ├── actions
│       │   │   ├── AbstractHeaderAction.ts
│       │   │   └── NavigateToPageAction.ts
│       │   ├── services 
│       │   └── state
│       │       ├── types
│       │       ├── HeaderState.ts
│       │       └── initialHeaderState.ts
│       ├── view
│       │    ├── navigation
│       │    │   ├── NavigationView.module.scss
│       │    │   └── NavigationView.tsx
│       │    ├── HeaderView.module.scss
│       │    └── HeaderView.tsx
│       └── headerController.ts
├── index.ts
└── store.ts
```

在上面的示例中，我们为标题域的技术细节创建了两个目录：```model``` 和 ```view``` 目录。 模型目录包含动作、服务和状态，视图目录包含视图组件、其可能的子组件和 ```CSS``` 定义。 模型的状态目录可以包含子域状态中使用的类型的子目录。 状态目录应始终包含子域状态和初始状态的类型定义。 ```services``` 目录包含一个或多个使用后端服务来控制后端模型的服务。

## 避免注释原则
> 避免在代码中注释。 唯一的例外是记录库的公共 ```API``` 时。

注释可能有问题。 你不能 100% 信任它们，因为它们可能具有误导性、过时或完全错误。 你只能信任源代码本身。 注释通常是完全不必要的，只会使代码更加冗长。 以下部分描述了避免编写注释并仍然使代码易于理解的几种方法。

### 正确命名
当你命名一个函数之类的东西时，你可能最终会在函数上附加注释。 为了避免写评论，必须专注于正确命名事物。 当遵循单一职责原则和统一命名原则时，应该更容易正确命名事物并避免注释。 下面是带有注释的函数示例：

```MessageBuffer.h```

```c++
class MessageBuffer {
    public:
    // Return false if buffer full,
    // true if message written to buffer
    bool write(const std::shared_ptr<Message>& message);
}
```

如果我们删除注释，我们将有以下代码：

```MessageBuffer.h```

```c++
class MessageBuffer {
    public:
    bool write(const std::shared_ptr<Message>& message);
}
```

单独删除评论并不是最好的解决方案，因为现在缺少一些关键信息。 这个布尔返回值是什么意思？ 这不是 100% 清楚的。 我们可以假设返回 ```true``` 意味着消息已成功写入，但没有关于返回 ```false``` 的信息。 我们只能假设这是一些错误，但不确定是什么错误。

除了去掉注释之外，我们应该给函数起一个更好的名字，重命名如下：

```MessageBuffer.h```

```c++
class MessageBuffer {
    public:
    bool writeIfBufferNotFull(
        const std::shared_ptr<Message>& message
    );
}
```

现在函数的目的很明确了，我们可以确定布尔返回值是什么意思了。 它表示消息是否已写入缓冲区。 现在我们也知道为什么写入消息会失败：缓冲区已满。 这将为函数调用者提供有关下一步操作的足够信息。 它可能应该等待一段时间，以便缓冲区读取器有足够的时间从缓冲区读取消息并释放一些空间。

下面是我曾经读过的一本书中的一个真实例子：

```c++
public interface Mediator {
  // To register an employee
  void register(Person person);
  
  // To send a message from one employee to another employee
  void connectEmployees(Person fromPerson,
                        Person toPerson,
                        String msg);
  
  // To display currently registered members
  void displayDetail();
}
```

上面的例子中有三个函数，每个函数都有一个问题。 第一个功能是注册一个人，但是评论说是注册一个员工。 因此，注释和代码之间存在不匹配。 在这种情况下，我相信代码胜过评论。 更正是删除评论，因为它没有带来任何价值。 它只会引起混乱。

第二个功能在评论中说它从一名员工向另一名员工发送消息。 函数名称告诉连接员工，但参数是人。 我假设评论的一部分是正确的：将消息从某人发送给其他人。 但是再一次，我更相信代码而不是评论，并假设消息是从一个人发送给另一个人的。 我们应该删除注释并重命名函数。

在第三个函数中，注释添加了函数名称中缺少的信息。 该评论还讨论了成员，因为代码的其他部分谈论的是雇员和人员。 使用了三个不同的术语：员工、人员和成员。 应该只选择一个术语。 让我们选择人这个词并系统地使用它。

下面是没有注释的重构版本：

```c++
public interface Mediator {
  void register(Person person);
  
  void send(String message, 
            Person sender,
            Person recipient);
  
  void displayDetailsOfRegisteredPersons();
}
```

### 在函数末尾单次返回命名值
一个函数应该有一个单一的 ```return``` 语句，并在函数的末尾返回一个命名的值。 然后代码阅读者可以通过查看函数的结尾来推断返回值的含义。

考虑以下示例：

```Metrics.h```

```c++
class Metrics
{
public:
  // ...

  static uint32_t addCounter(
    CounterFamily counterFamily,
    const std::map<std::string, std::string>& labels
  );
  
  static void incrementCounter(uint32_t counterIndex,
                               size_t incrementAmount);  
                               
  // addGauge...
  // setGaugeValue...
}
```

```addCounter``` 函数的返回值是多少？ 有人可能认为需要注释来描述返回值，因为不清楚 ```uint32_t``` 是什么意思。 我们可以引入一个要从函数返回的命名值（=变量/常量），而不是编写注释。 命名返回值背后的想法是它无需注释即可传达返回值的语义。 在 C++ 中，你从函数声明跳转到函数定义以查看函数返回的内容。 下面是 ```addCounter``` 函数的实现：

```Metrics.cpp```

```c++
```

在上面的实现中，我们在函数末尾返回了一个命名值。 我们所要做的就是查看函数的末尾并找到 ```return``` 语句，它应该告诉我们神秘的 ```uint32_t``` 类型返回值的含义：它是一个计数器索引。 我们可以发现 ```increaseCounter``` 函数需要一个 ```counterIndex``` 参数，这在首先调用 ```addCounter``` 函数、存储返回的计数器索引以及稍后在调用 ```increaseCounter``` 函数时使用该存储的计数器索引之间建立了联系。

### 返回类型别名

在前面的例子中，```addCounter``` 函数中有神秘的 ```uint32_t``` 类型的返回值。 我们了解了在函数末尾引入命名返回值如何帮助传达返回值的语义。 但是有一种更好的方法来传达返回值的语义。 许多语言（如 ```C++``` 和 ```TypeScript```）都提供了可用于传达返回值语义的类型别名。 下面是我们为 ```uint32_t``` 类型引入 ```CounterIndex``` 类型别名的示例：

```Metrics.h```

```c++
class Metrics
{
public:
  using CounterIndex = uint32_t;

  // ...

  static CounterIndex addCounter(
    CounterFamily counterFamily,
    const std::map<std::string, std::string>& labels
  );
  
  static void incrementCounter(CounterIndex counterIndex,
                               size_t incrementAmount);
}
```

这是 ```TypeScript``` 中的相同示例：

```Metrics.ts```

```typescript
export type CounterIndex = number;

export default class Metrics {
  // ...

 static addCounter(
    counterFamily: CounterFamily,
    labels: Record<string, string>
  ): CounterIndex;
   
  static incrementCounter(counterIndex: CounterIndex, incrementAmount: number): void;
}
```

有些语言，如 ```Java```，没有类型别名。 然后你可以为返回值引入一个包装类。 这是 ```Java``` 中的相同示例：

```CounterIndex.java```

```java
public class CounterIndex {
  private final int value;

  public CounterIndex(final int value) {
    this.value = value;
  }

  public int get() {
    return value;
  }
}
```

```Metrics.java```

```java
public final class Metrics {
  // ...

  public static CounterIndex addCounter(
    final CounterFamily counterFamily,
    final Map<String, String> labels
  ) {
    // ...
  }

  public static void incrementCounter(
    CounterIndex counterIndex,
    double incrementAmount
  ) {
    // ...
  }
}
```

我们可以改进上面的例子。 ```CounterIndex``` 类可以派生自通用 Value 类：

```java
public class Value<T> {
  private final T value;

  public Value(final T value) {
    this.value = value;
  }

  public T get() {
    return value;
  }
}

public class CounterIndex extends Value<Integer> {
  // ...
}
```

我们可以大大改进上述指标示例。 首先，我们应该避免对原始类型的痴迷。 我们不应该从 ```addCounter``` 方法返回一个索引，但我们应该将该方法重命名为 ```createCounter``` 并从该方法返回一个 ```Counter``` 类的实例。 然后我们应该通过将 ```incrementCounter``` 方法移动到 ```Counter``` 类并将其命名为 ```increment``` 来使示例更加面向对象。 此外，```Metrics``` 类的名称应更改为 ```MetricFactory```。 最后，我们应该使 ```MetricFactory``` 类成为单例而不是包含静态方法。

### 提取布尔表达式常量
通过为布尔表达式提取常量，我们可以消除注释。 下面是一个示例，其中注释写在 ```if``` 语句及其布尔表达式下方：

```MessageBuffer.cpp```

```c++
bool MessageBuffer::writeIfBufferNotFull(
  const std::shared_ptr<Message>& message
) {
  bool messageWasWritten{false};
  
  if (m_messages.size() < m_maxBufferSize)
  {
    // Buffer is not full
    m_messages.push_back(message);
    messageWasWritten = true;
  }
  
  return messageWasWritten;
}
```

通过引入一个用于"缓冲区已满"检查的常量，我们可以摆脱"缓冲区未满"的注释：

```MessageBuffer.cpp```

```c++
bool MessageBuffer::writeIfBufferNotFull(
  const std::shared_ptr<Message> message
) {
  bool messageWasWritten{false};
  
  const bool bufferIsNotFull =
    m_messages.size() < m_maxBufferSize;
  
  if (bufferIsNotFull)
  {
    m_messages.push_back(message);
    messageWasWritten = true;
  }
  
  return messageWasWritten;
}
```

### 提取命名常量或枚举类型
如果你在代码中遇到幻数，你应该为该值引入命名常量或枚举类型 (```enum```)。 在下面的示例中，我们返回两个幻数 ```0``` 和 ```1```：

```main.cpp```

```c++
int main()
{
  Application application;
  
  if (application.run())
  {
    // Application was run successfully
    return 0;
  }

  // Exit code: failure
  return 1;
}
```

让我们引入一个枚举类型 ```ExitCode```，并使用它来代替幻数：

```main.cpp```

```c++
enum class ExitCode
{
  Success = 0,
  Failure = 1
};

int main()
{
  ExitCode exitCode;
  Application application;
  const bool appWasSuccessfullyRun = application.run();
  
  if (appWasSuccessfullyRun)
  {
    exitCode = ExitCode::Success;
  }
  else
  {
    exitCode = ExitCode::Failure;
  }

  return static_cast<int>(exitCode);
}
```

如果需要，现在可以轻松添加更多带有描述性名称的退出代码。

### 提取函数

如果你打算在一段代码上方写注释，你应该将该段代码提取到一个新函数中。 当你提取一个命名良好的函数时，你不需要写那个注释。 新提取的函数的名称用作文档。 下面是一个带有一些注释代码的示例：

```MessageBuffer.cpp```

```c++
void MessageBuffer::writeFitting(
  std::deque<std::shared_ptr<Message>>& messages
) {
  if (m_messages.size() + messages.size() <= m_maxBufferSize)
  {
    // All messages fit in buffer
    m_messages.insert(m_messages.end(),
                      messages.begin(),
                      messages.end());
                      
    messages.clear();
  }
  else
  {
    // All messages do not fit, write only messages that fit
    const auto messagesEnd = messages.begin() +
                             m_maxBufferSize -
                             m_messages.size();
                             
    m_messages.insert(m_messages.end(),
                      messages.begin(),
                      messagesEnd);
                      
    messages.erase(messages.begin(), messagesEnd);
  }
}
```

这是通过提取两个新方法重构注释的相同代码：

```MessageBuffer.cpp```

```c++
void MessageBuffer::writeFitting(
  std::deque<std::shared_ptr<Message>>& messages
) {
  const bool allMessagesFit = m_messages.size() +
                              messages.size() <= m_maxBufferSize;
                              
  if (allMessagesFit)
  {
    writeAll(messages)
  }
  else
  {
    writeOnlyFitting(messages);
  }
}

void MessageBuffer::writeAll(
  std::deque<std::shared_ptr<Message>>& messages
) {
  m_messages.insert(m_messages.end(),
                    messages.begin(),
                    messages.end());
                    
  messages.clear();
}

void MessageBuffer::writeOnlyFitting(
  std::deque<std::shared_ptr<Message>>& messages
) {
  const auto messageCountThatFit = m_maxBufferSize -
                                   m_messages.size();
                                   
  const auto messagesEnd = messages.begin() +
                           messageCountThatFit;
                           
  m_messages.insert(m_messages.end(),
                    messages.begin(),
                    messagesEnd);
                    
  messages.erase(messages.begin(), messagesEnd);
}
```

### 命名匿名函数
匿名函数在函数式编程中很常见，例如，在使用 ```forEach```、```map```、```filter``` 和 ```reduce``` 等算法时。 当一个匿名函数很长或者很复杂时，你应该给它起一个描述性的名字，如果它太长就拆分成多个函数。 这样，你就可以消除评论。

在下面的 ```TypeScript``` 示例中，我们有一个带注释的匿名函数：

```typescript
// ...

fs.watchFile('/etc/config/LOG_LEVEL', () => {
  // Update new log level
  try {
    const newLogLevel = fs.readFileSync('/etc/config/LOG_LEVEL', 'utf-8'}).trim();
    tryValidateLogLevel(newLogLevel);
    process.env.LOG_LEVEL = newLogLevel;
  } catch (error) {
    // ...
  }
});
```

我们可以重构上面的例子，去掉注释，给匿名函数起个名字：

```typescript
function updateNewLogLevel() {
  try {
    const newLogLevel = fs.readFileSync('/etc/config/LOG_LEVEL', 'utf-8'}).trim();
    tryValidateLogLevel(newLogLevel);
    process.env.LOG_LEVEL = newLogLevel;
  } catch (error) {
    // ...
  }
}

fs.watchFile('/etc/config/LOG_LEVEL', updateNewLogLevel);
```

### 避免在 Bash Shell 脚本中注释
许多程序员，包括我自己，并不喜欢 ```Linux shell``` 命令和脚本的神秘语法。 如果你不经常使用脚本，即使是最简单的表达式的语法也可能难以理解和记忆。 当然，最好的办法是避免编写复杂的 ```Linux shell``` 脚本，而是使用合适的编程语言，如 ```Python```。 但有时，使用 ```shell``` 脚本执行某些操作会更容易。 由于 ```shell``` 脚本中的语法和命令可能难以理解，因此许多开发人员倾向于通过在脚本中添加注释来解决问题。

接下来，介绍了使脚本在没有注释的情况下更易于理解的替代方法。 让我们考虑一下我遇到的一个真实脚本中的以下示例：

```sh
create_network() {
  #create only if not existing yet
  if [[ -z "$(docker network ls | grep $DOCKER_NETWORK_NAME )" ]];
  then
    echo Creating $DOCKER_NETWORK_NAME
    docker network create $DOCKER_NETWORK_NAME
  else
    echo Network $DOCKER_NETWORK_NAME already exists
  fi
}
```

下面是具有以下更改的相同示例：

- 注释被删除，之前的注释表达式被移动到一个命名良好的函数
- 删除了表达式中的否定，交换了 then 和 else 分支的内容
- 变量名采用驼峰式大小写以增强可读性

```sh
dockerNetworkExists() { [[ -n "$(docker network ls | grep $1 )" ]]; }

createDockerNetwork() {
  if dockerNetworkExists $networkName; then
    echo Docker network $networkName already exists
  else
    echo Creating Docker network $networkName
    docker network create $networkName
  fi
}
```

如果你的脚本接受参数，请为参数指定适当的名称，例如：

```sh
dataFilePathName=$1
schemaFilePathName=$2
```

脚本读者不必记住 \$1 或 \$2 的含义，你也不必插入任何注释来阐明参数的含义。

如果你在 ```Bash shell``` 脚本中有一个复杂的命令，你不应该给它附加注释，而是提取一个具有适当名称的函数来描述该命令。

下面的示例包含注释：

```sh
# Update version in Helm Chart.yaml file
sed -i "s/^version:.*/version: $VERSION/g" helm/service/Chart.yaml
```

这是重构为包含函数的上述示例

```shell
updateHelmChartVersionInChartYamlFile() {
  sed -i "s/^version:.*/version: $1/g" helm/service/Chart.yaml
}

updateHelmChartVersionInChartYamlFile $version
```


这是另一个例子：

```sh
getFileLongestLineLength() {
  echo $(awk '{ if (length($0) > max) max = length($0) } END { print max }' $1)
}

configFileLongestLineLength = $(getFileLongestLineLength $configFilePathName)
```

## 函数单独返回原则
> 最好在函数末尾使用单个 ```return``` 语句，以清楚地传达返回值的含义并使重构函数更容易。

如果返回值类型不直接传达它，则在函数末尾带有命名值的单个 ```return``` 语句清楚地传达了返回值语义。 例如，如果你从函数返回一个基本类型的值，如整数或布尔值，则不一定 100% 清楚返回值的含义。 但是，当你在函数末尾返回命名值时，返回变量的名称传达了语义。

你可能认为无法在函数中间返回值会降低函数的可读性，因为有很多嵌套的 ```if``` 语句。 这是可能的，但应该记住函数应该很小。 目标是在单个函数中最多包含 5-9 行语句。 遵循该规则，你永远不会在单个函数中有大量嵌套的 ```if``` 语句。

在函数末尾有一个 ```return``` 语句使得重构函数更容易。 你可以使用 ```IDE``` 提供的自动重构工具。 从包含 ```return``` 语句的代码中提取新函数总是比较困难。 对于带有 ```break``` 或 ```continue``` 语句的循环也是如此。 在不包含 ```break``` 或 ```continue``` 语句的循环内重构代码会更容易。

在某些情况下，在函数末尾返回单个值可以使代码更直接并且需要更少的代码行。

下面是一个有两个返回位置的函数的例子：

```TransformThread.cpp```

```c++
bool TransformThread::transform(
  const std::shared_ptr<InputMessage>& inputMessage
) {
  auto outputMessage = m_outputMessagePool->acquireMessage();
  bool messageIsFilteredIn;
  
  const bool messageWasTransformed = 
    m_messageTranformer->transform(inputMessage,
                                   outputMessage,
                                   messageIsFilteredIn);

  if (messageWasTransformed && messageIsFilteredIn)
  {
    m_outputMessages.push_back(outputMessage);
  }
  else
  {
    m_outputMessagePool->returnMessage(outputMessage);

    if (!messageWasTransformed)
    {
        return false;
    }
  }

  return true;
}
```

在分析上述函数时，我们注意到它将输入消息转换为输出消息。 我们可以得出结论，该函数在消息转换成功时返回 ```true```。 我们可以通过将其重构为仅包含一个 ```return``` 语句来缩短该函数。 重构后，100%清楚函数返回值的含义。

```TransformThread.cpp```

```c++
bool TransformThread::transforme(
  const std::shared_ptr<InputMessage>& inputMessage
) {
  auto outputMessage = m_outputMessagePool->acquireMessage();
  bool messageIsFilteredIn;
  
  const bool messageWasTransformed =
      m_messageTransformer->transform(inputMessage,
                                      outputMessage,
                                      messageIsFilteredIn);

  if (messageWasTransformed && messageIsFilteredIn)
  {
    m_outputMessages.push_back(outputMessage);
  }
  else
  {
    m_outputMessagePool->return(outputMessage);
  }

  return messageWasTransformed;
}
```

作为此规则的一个例外，当函数具有最佳长度时，你可以在一个函数中包含多个 ```return``` 语句，如果将其重构为包含单个 ```return``` 语句，则会变得太长。 此外，要求返回值的语义从函数名或函数的返回类型中明确。 下面是一个带有多个 ```return``` 语句的函数的例子。 从函数名也可以清楚的看出返回值是什么意思。 此外，函数的长度是最佳的：七个语句。

```c++
private areEqual(
  iterator: MyIterator<T>,
  anotherIterator: MyIterator<T>
): boolean {
  while (iterator.hasNextElement()) {
    if (anotherCollectionIterator.hasNextElement()) {
      if (iterator.getNextElement() !== 
          anotherCollectionIterator.getNextElement()) {
       return false;
      }
    } else {
      return false;
    }
  }
  
  return true;
}
```

如果我们重构上述代码以包含单个 ```return``` 语句，代码将变得太长（10 条语句）以适应一个函数，如下所示。 在这种情况下，我们应该更喜欢上面的代码而不是下面的代码。

```c++
private areEqual(
  iterator: MyIterator<T>,
  anotherIterator: MyIterator<T>
): boolean {
  let areEqual = true;
  
  while (iterator.hasNextElement()) {
    if (anotherCollectionIterator.hasNextElement()) {
      if (iterator.getNextElement() !== 
          anotherCollectionIterator.getNextElement()) {
       areEqual = false;
       break;
      }
    } else {
      areEqual = false;
      break;
    }
  }
  
  return areEqual;
}
```

作为此规则的第二个例外，你可以在一个工厂中使用多个返回位置，因为你可以从工厂名称中知道它创建的对象类型。 下面是一个包含多个返回语句的示例工厂：

```c++
enum class CarType 
{
  Audi,
  Bmw,
  MercedesBenz
};

class Car 
{
  // ...
};

class Audi : public Car 
{
  // ...
};

class Bmw : public Car 
{
  // ... 
};

class MercedesBenz : public Car 
{
  // ... 
};

class CarFactory 
{
public:
  std::shared_ptr<Car> createCar(const CarType carType) 
  {
    switch(carType) 
    {
      case CarType::Audi:
        return std::make_shared<Audi>();
      case CarType::Bmw:
        return std::make_shared<Bmw>();
      case CarType::MercedesBenz:
        return std::make_shared<MercedesBenz>();
      default:
        throw std::invalid_argument("Unknown car type");
    }
  }
};
```

## 生产代码原则更喜欢静态类型语言
> 实施生产软件时，首选静态类型语言。 你可以将 Python 等非类型化语言用于非生产代码，例如集成、端到端和自动化非功能测试。 你可以将 ```Bash shell``` 脚本用于小脚本。

你可以使用没有类型的小型软件组件进行管理，但是当它变得越来越大并且越来越多的人使用它时，静态类型的好处就会变得明显。

让我们分析一下使用无类型语言可能会引发哪些潜在问题：

- 函数参数可能以错误的顺序给出
- 函数参数可能给出了错误的类型
- 并非所有函数参数都给出（适用于某些语言）
- 函数返回值类型可能被误解
- 被迫编写公共 ```API``` 注释来描述函数签名
- 测试不一定发现类型错误

### 函数参数可能以错误的顺序给出

使用无类型语言时，如果参数类型相同，则可能会以错误的顺序为函数提供参数。 你不会因为这个错误而得到编译错误。 现代 ```IDE``` 可以显示函数调用的嵌入参数提示。 这是你应该考虑在 ```IDE``` 中启用的功能。 这些参数提示可能会揭示函数参数未按正确顺序给出的情况。

### 函数参数可能给出了错误的类型
使用无类型语言时，你可以为函数参数提供错误的类型。 例如，一个函数需要一个数字的字符串表示，但你提供了一个数字。 正确命名函数参数会有所帮助。 不应将字符串参数命名为 ```amount```，该参数应命名为 ```amountString``` 或 ```amountAsString```。

### 并非所有函数参数都给出
在某些语言中，例如 ```JavaScript```，你可以在调用函数时为函数提供比预期更少的参数。 这导致函数调用中未给出的参数具有未定义的值。 调用参数太少的函数不会出错。

### 函数返回值类型可能被误解
确定函数返回值类型可能很困难。 从函数名称上不一定能 100% 清楚。 例如，如果你有一个名为 ```getValue``` 的函数，它不是 100% 清楚返回值类型是什么。 只有当你很好地了解函数的上下文时，它才可能是显而易见的。 作为一项改进，该函数应适当命名，例如：```getValueAsString()```，如果返回值始终为字符串。 如果从函数名看不清楚返回值类型，则必须分析函数源代码确定返回值类型。 这是不必要且容易出错的手动工作，使用类型化语言可以避免。

### 被迫编写公共 ```API``` 注释
使用无类型语言时，你可能被迫使用注释来记录公共 ```API```。 这是可以通过使用静态类型避免的额外工作。 编写带有注释的 ```API``` 文档很容易出错。 你可能会不小心在 ```API``` 文档中写入错误信息，或者在更改 ```API``` 时忘记更新文档。 同样，```API``` 文档的读者也会犯错误。 他们可能根本不阅读 ```API``` 文档。 或者他们之前读过但后来记错了。

### 测试中未发现类型错误
这是最大的问题。 你可能会认为，如果你的代码中存在与具有正确类型的正确函数参数相关的错误，测试将揭示这些错误。 这通常是一个错误的假设。 单元测试不会发现问题，因为你模拟了其他类。 当你集成软件组件时，你只能在集成测试中发现问题（即，测试函数调用其他真实函数而不是模拟）。 根据测试金字塔，集成测试仅涵盖代码库的一个子集，少于单元测试。 并且根据集成测试代码覆盖率，某些函数参数顺序或参数/返回值类型正确性问题可能未经测试并逃逸到生产环境中。

## 重构原则

> 你不可能在第一次尝试时就写出完美的代码，因此你应该始终为将来的重构预留一些时间。

即使你正在为新的软件组件编写代码，你也需要进行重构。 重构不仅仅与遗留代码库相关。 如果你不重构，你就会让软件中的技术债务增长。 重构背后的主要思想是，没有人可以在第一次尝试时写出完美的代码。 重构意味着你更改代码而不更改实际功能。 重构之后，大部分测试应该仍然通过，代码组织方式不同，并且你有更好的面向对象设计和改进的事物命名。 重构通常不会影响集成测试，但会影响单元测试，具体取决于重构的类型和规模。 在估算重构工作量时请记住这一点。

当我们计划事情时，我们不一定会为重构预留任何或足够的时间。 当我们为史诗、功能和用户故事提供工作估算时，我们应该意识到重构的需要，并在我们的初始工作估算（不包括重构）的基础上增加一些额外的时间。 重构是管理层不一定了解清楚的工作。 管理层应该支持重构的需要，即使它没有给最终用户带来明确的附加值。 但它通过不让代码库腐烂和消除技术债务来带来价值。 如果你的软件积累了大量技术债务，那么开发新功能和维护软件的成本就会很高。 此外，软件质量较低，可能会出现许多错误并降低客户满意度。

下面列出了最常见的代码异味和解决这些问题的重构技术：

|              代码气味               |    重构方案    |
| :---------------------------------: | :------------: |
|            非描述性名称             |      改名      |
|               长方法                |    提取方法    |
|             复杂的表达              |    提取常量    |
| 长 switch-case 或 if-then-else 语句 | 用多态替换条件 |
|             长参数列表              |  引入参数对象  |
|           Shotgun surgery           | 用多态替换条件 |
|            取反布尔条件             |  反转 If 语句  |

### 改名
这可能是最常用的重构技术。 你通常不会在第一次尝试时就获得正确的名称，需要进行重命名。 现代 ```IDE``` 提供的工具可帮助重命名代码中的内容：接口、类、函数和变量。 ```IDE``` 的重命名功能始终优于普通的旧搜索和替换方法。 如果使用搜索和替换方法，你可能会不小心重命名不想重命名的内容，或者不重命名应该重命名的内容。

### 提取方法
这可能是第二个最常用的重构技术。 当你实现一个类的公共方法时，该方法的代码行数会迅速增加。 一个函数最多应包含 5-9 条语句，以保持其可读性和可理解性。 当一个公共方法太长时，应该提取一个或多个私有方法，从公共方法中调用这些私有方法。 每个现代 ```IDE``` 都有一个提取方法重构工具，可让你轻松提取私有方法。 选择要提取到新方法的代码行，然后按 ```IDE``` 的快捷键以使用提取方法功能。 然后为提取的方法起一个描述性的名称，就大功告成了。 在某些情况下，重构不是自动的。 例如，如果要提取的代码中包含影响函数执行流程的 ```return```、```break``` 或 ```continue``` 语句（导致多个返回点）。 如果你想保持代码可重构，请避免使用 ```break``` 和 ```continue``` 语句，并且在函数末尾只有一个 ```return``` 语句。 在 ```IDE``` 中完成提取之前，你可以更好地组织提取方法的参数。

### 提取常量
如果你有一个复杂的表达式（布尔值或数字），请将表达式的值分配给一个常量。 常量的名称传达了有关表达式的信息。 下面是一个示例，我们通过将表达式提取为常量来使 if 语句更好读：

```js
// ...

if (dataSourceSelectorIsOpen &&
    measureSelectorIsOpen &&
    dimensionSelectorIsOpen
) {
  dataSourceSelectorContentElem.style.height =
    `${0.2 * availableHeight}px`;
    
  measureSelectorContentElem.style.height =
    `${0.4 * availableHeight}px`;
    
  dimensionSelectorContentElem.style.height =
    `${0.4 * availableHeight}px`;
} else if (!dataSourceSelectorIsOpen &&
           !measureSelectorIsOpen &&
           dimensionSelectorIsOpen
) {
    dimensionSelectorContentElem.style.height
      = `${availableHeight}px`;
}
```

让我们提取常量：

```js
// ...

const allSelectorsAreOpen = dataSourceSelectorIsOpen &&
                            measureSelectorIsOpen &&
                            dimensionSelectorIsOpen;
                            
const onlyDimensionSelectorIsOpen = 
    !dataSourceSelectorIsOpen && 
    !measureSelectorIsOpen &&
    dimensionSelectorIsOpen;

if (allSelectorsAreOpen) {
  dataSourceSelectorContentElem.style.height =
    `${0.2 * availableHeight}px`;
    
  measureSelectorContentElem.style.height =
    `${0.4 * availableHeight}px`;
    
  dimensionSelectorContentElem.style.height =
    `${0.4 * availableHeight}px`;  
} else if (onlyDimensionSelectorIsOpen) {
  dimensionSelectorContentElem.style.height =
    `${availableHeight}px`;
}
```

下面是 ```C++``` 中的一个示例，其中我们返回一个布尔表达式：

```c++
bool AvroFieldSchema::equals(
  const std::shared_ptr<AvroFieldSchema>& otherAvroFieldSchema
) const
{
  return m_type == otherAvroFieldSchema->getType() &&
         m_name.substr(m_name.find_first_of('.') + 1U) ==
         otherField->getName().substr(
          otherField->getName().find_first_of('.') + 1U);
}
```

理解布尔表达式的含义可能具有挑战性。 我们可以通过添加注释来改进该功能：（我们假设每个字段名称都有一个不能包含点字符的根命名空间）

```c++
bool AvroFieldSchema::equals(
  const std::shared_ptr<AvroFieldSchema>& otherAvroFieldSchema
) const
{
  // Field schemas are equal if field types are equal and
  // field names without the root namespace are equal
  return m_type == otherAvroFieldSchema->getType() &&
         m_name.substr(m_name.find_first_of('.') + 1U) ==
         otherField->getName().substr(
          otherField->getName().find_first_of('.') + 1U);
}
```

但是我们不应该写评论，因为评论从来都不是 100% 可信的。 有可能评论和相关代码不同步：有人更改了功能而没有更新评论，或者只修改了评论但没有更改功能。 让我们通过删除注释并提取多个常量来重构上面的示例。 下面的函数比原来的要长，但它当然更具可读性。 如果你查看该方法的最后两个语句，你可以理解在什么情况下两个字段模式是相等的。 编译器的工作应该是使以下较长版本的函数与原始函数一样高效。

```c++
bool AvroFieldSchema::equals(
  const std::shared_ptr<AvroFieldSchema>& otherAvroFieldSchema
) const
{
  const auto fieldNameWithoutRootNamespace =
    m_name.substr(m_name.find_first_of('.') + 1U);

  const auto otherFieldName = otherAvroFieldSchema->getName();

  const auto otherFieldNameWithoutRootNamespace =
    otherFieldName.substr(otherFieldName.find_first_of('.') + 1U);

  const bool fieldTypesAndNamesWithoutRootNsAreEqual = 
    m_type == otherAvroFieldSchema->getType() &&
    fieldNameWithoutRootNamespace == otherFieldNameWithoutRootNamespace;

  const bool fieldSchemasAreEqual =
    fieldTypesAndNamesWithoutRootNsAreEqual;

  return fieldSchemasAreEqual;
}
```

### 用多态替换条件
假设你在代码中遇到大型 ```switch-case``` 语句或 ```if/else-if``` 结构（不考虑工厂中的代码）。 这意味着你的软件组件没有正确的面向对象设计。 你应该用多态替换条件。 当你在软件组件中引入适当的 ```OOD``` 时，你将功能从 ```switch``` 语句的 ```case``` 分支转移到实现特定接口的不同类。 同样，你将代码从 ```if``` 和 ```else-if``` 语句移动到实现特定接口的不同类。 这样，你就可以消除 ```switch-case``` 和 ```if/else-if``` 语句，并将它们替换为多态方法调用。

下面是一个非面向对象设计的 ```TypeScript``` 例子：

```typescript
function doSomethingWith(chart: Chart) {
  if (chart.getType() === 'column') {
    // do this
  } else if (chart.getType() === 'pie') {
    // do that
  } else if (chart.getType() === 'geographic-map') {
    // do a third thing
  }
}
```

让我们用多态替换上面的条件：

```typescript
interface Chart {
  doSomething(...): void;
}

class ColumnChart implements Chart {
  doSomething(...): void {
    // do this
  }
}

class PieChart implements Chart {
  doSomething(...): void {
    // do that
  }
}

class GeographicMapChart implements Chart {
  doSomething(...): void {
    // do a third thing
  }
}

function doSomethingWith(chart: Chart) {
  chart.doSomething();
}
```

假设你正在实现一个数据可视化应用程序，并且你的代码中有很多地方需要检查图表类型并需要引入新的图表类型。 这可能意味着你必须在代码的许多地方添加新的 ```case``` 或 ```else-if``` 语句。 这种方法非常容易出错，被称为鸟枪手术，因为你需要找到代码库中所有需要修改代码的地方。 你应该做的是进行适当的面向对象设计并引入一个包含新功能的新图表类，而不是通过在多个地方修改代码来引入新功能。

### 引入参数对象
如果函数的参数超过 5-7 个，则应引入参数对象以减少参数的数量，从而使函数签名更具可读性。 下面是一个参数过多的示例构造函数：

```KafkaConsumer.java```

```java
public class KafkaConsumer {
  public KafkaConsumer(
    final List<String> brokers,
    final List<String> topics,
    final List<String> extraConfigEntries,
    final boolean tlsIsUsed,
    final boolean certShouldBeVerified,
    final String caFilePathName,
    final String certFilePathName,
    final String keyFilePathName)
  {
    // ...
  }
}
```

让我们将传输层安全性 (```TLS```) 相关参数分组到一个名为 ```TlsOptions``` 的参数类中：

```TlsOptions.java```

```java
public class TlsOptions {
  public TlsOptions(
    final boolean tlsIsUsed,
    final boolean certShouldBeVerified,
    final String caFilePathName,
    final String certFilePathName,
    final String keyFilePathName
  ) {
    // ...
  }
}
```

现在我们可以修改 ```KafkaConsumer``` 构造函数以利用 ```TlsOptions``` 参数类：

```KafkaConsumer.java```

```java
public class KafkaConsumer {
  public KafkaConsumer(
    final List<String> brokers,
    final List<String> topics,
    final List<String> extraConfigEntries,
    final TlsOptions tlsOptions
  ) {
    // ...
  }
}
```

### 反转 If 语句

这是现代 ```IDE``` 可以为你完成的重构。

下面是一个 ```Python``` 示例，在 ```if``` 语句条件中包含一个取反的布尔表达式。 请注意布尔表达式读起来有多难：```hostMountFolder``` 不是 ```None```。 这是一个双重否定的陈述，因此难以阅读。

```python
def getBehaveTestFolder(relativeTestFolder = ''):
  hostMountFolder = os.environ.get("HOST_MOUNT_FOLDER")
  
  if hostMountFolder is not None:
    finalHostMountFolder = hostMountFolder
    if hostMountFolder.startswith("/mnt/c/"):
      finalHostMountFolder = hostMountFolder.replace("/mnt/c/", "/c/", 1)
                                                     
    behaveTestFolder = finalHostMountFolder + '/' + relativeTestFolder
  else:
    behaveTestFolder = os.getcwd()

  return behaveTestFolder
```

让我们重构上面的代码，以便反转 ```if``` 和 ```else``` 语句：

```python
def getBehaveTestFolder(relativeTestFolder = ''):
  hostMountFolder = os.environ.get("HOST_MOUNT_FOLDER")
  
  if hostMountFolder is None:
    behaveTestFolder = os.getcwd()
  else:
    finalHostMountFolder = hostMountFolder
    if hostMountFolder.startswith("/mnt/c/"):
      finalHostMountFolder = hostMountFolder.replace("/mnt/c/", "/c/", 1)
    behaveTestFolder = finalHostMountFolder + '/' + relativeTestFolder

  return behaveTestFolder
```

下面是 ```C++``` 中的另一个示例：

```c++
if (somePointer != nullptr) 
{
  // Do thing 1
}
else
{
  // Do thing 2
}
```

我们不应该对 ```if``` 语句的条件进行否定。 让我们重构上面的例子：

```c++
if (somePointer == nullptr) 
{
  // Do thing 2
}
else
{
  // Do thing 1
}
```

## 静态代码分析原则
> 让计算机为你查找代码中的错误和问题。

静态代码分析工具代表你查找错误和与设计相关的问题。 使用多种静态代码分析工具来获得全部好处。 不同的工具可能检测到不同的问题。 使用静态代码分析工具可以让人们在代码审查中腾出时间来专注于自动化无法解决的事情。

下面列出了一些针对不同语言的常见静态代码分析工具：

- Java
  - Jetbrains IntelliJ IDEA IDE 检查
  - SonarLint
  - SonarQube/SonarCloud
- C++
  - Jetbrains CLion IDE 检查
  - Clang-Tidy
  - MISRA C++ 2008 准则
  - CppCheck
  - SonarLint
  - SonarQube/SonarCloud
- TypeScript
  - Jetbrains WebStorm IDE 检查
  - ESLint（+ 各种插件，如 TypeScript 插件）
  - SonarLint
  - SonarQube/SonarCloud

基础设施和部署代码应该与源代码一样对待。 请记住还要对你的基础架构和部署代码运行静态代码分析工具。 有多种工具可用于分析基础架构和部署代码，例如 ```Checkcov```，可用于分析 ```Terraform```、```Kubernetes``` 和 ```Helm``` 代码。 ```Helm``` 工具包含一个用于分析 ```Helm``` 图表文件的 ```linting``` 命令，而 ```Hadolint``` 是一个用于静态分析 ```Dockerfile``` 的工具。

### 常见的静态代码分析问题

|                    问题                     |                        描述/解决方案                         |
| :-----------------------------------------: | :----------------------------------------------------------: |
|                 检查实例链                  | 这个问题表明有利于面向对象设计的条件链。 使用多态性重构技术替换条件来解决这个问题。 |
|                 羡慕的功能                  |         使用上一章中的别问，说明原则来解决这个问题。         |
|                具体类的使用                 |          使用上一章的反接口原则程序来解决这个问题。          |
|                分配函数参数                 | 不要修改函数参数，而是引入一个新变量。 在 ```Java``` 中，你可以通过将函数参数声明为 ```final``` 来避免此问题。 |
|                注释掉的代码                 | 删除注释掉的代码。 如果你将来需要那段代码，它在版本控制系统中永远可用。 |
|                 常量正确性                  | 尽可能使变量和参数为 ```const``` 或 ```final``` 以实现不变性并避免意外修改 |
|          嵌套的 ```switch``` 语句           |    主要只在工厂中使用 ```switch``` 语句。 不要嵌套它们。     |
|               嵌套条件表达式                | 条件表达式 (?:) 不应该嵌套，因为它极大地阻碍了代码的可读性。 |
|            过于复杂的布尔表达式             | 将布尔表达式拆分为多个部分并引入常量来存储这些部分和最终表达式 |
|               表达式可以简化                |                   这可以由 IDE 自动重构。                    |
|      没有默认分支的 ```switch``` 语句       | 始终引入默认分支并从那里抛出异常。 否则，当你将 ```switch``` 语句与枚举一起使用时，在添加 ```switch``` 语句未处理的新枚举值后，你可能会遇到奇怪的问题。 |
|              ```Demeter```法则              | 对象知道的太多了。 它耦合到另一个对象的依赖关系，这会产生额外的耦合并使代码更难更改。 |
|                重用局部变量                 | 与其为了不同的目的重用一个变量，不如引入一个新变量。 可以适当地命名该新变量以描述其用途。 |
|                变量范围太广                 |                    仅在需要之前引入变量。                    |
|                  保护字段                   | 子类可以修改超类的受保护状态，而超类无法控制它。 这是破坏封装的迹象，应该避免。 |
|       打破封装：可修改/可变字段的返回       | 使用上一章的 不要将可修改的内部状态泄露到对象之外原则来解决这个问题。 |
| 打破封装：从方法参数到可修改/可变字段的赋值 | 使用上一章中的不要从方法参数分配给可修改字段原则来解决这个问题。 |
|               非常量公共字段                |     任何人都可以修改公共字段。 这会破坏封装，应该避免。      |
|         过于宽泛的```catch-block```         | 这可能表明设计错误。 例如，如果你只应捕获应用程序的基本错误类，则不要捕获该语言的基本异常类。 在下一节中阅读有关处理异常的更多信息 |

## 错误/异常处理原则
```C++```、```Java``` 和 ```TypeScript``` 等许多语言都有异常处理机制，可以处理错误和异常情况。 首先，我想明确区分这两个词：

> 错误是可能发生的事情，应该为此做好准备。 例外是永远不应该发生的事情。

你在代码中定义错误并在函数中引发错误。 例如，如果你尝试写入文件，则必须为磁盘已满的错误做好准备，或者如果你正在读取文件，则必须为文件不存在（不再存在）的错误做好准备。

许多错误是可以恢复的。 你可以从磁盘中删除文件以释放一些空间来写入文件。 或者，如果找不到文件，你可以向用户提供"找不到文件"错误，然后用户可以使用不同的文件名重试该操作，例如。 异常是你通常不会在应用程序中定义的东西，但系统会在异常情况下引发它们，例如遇到编程错误时。

例如，当内存不足而无法执行内存分配时，或者当编程错误导致数组索引越界或空指针时，都会引发异常。 抛出异常时，程序无法继续正常执行，可能需要终止。 这就是为什么许多异常可以归类为不可恢复的错误。 在某些情况下，可以从异常中恢复。 假设 ```Web``` 服务在处理 ```HTTP``` 请求时遇到空指针异常。 在这种情况下，你可以终止当前请求的处理，向客户端返回错误响应，并继续正常处理进一步的请求。 这取决于软件组件如何处理异常情况。

不要将此处的错误与 ```Java``` 错误（继承自 ```Error``` 类）混淆。 它们是致命错误，表明存在严重问题，出现恐慌情况。 正如 ```Java``` 文档所说，你不应该在代码中发现这些致命错误。 在类名中使用"错误"一词来表示致命情况是 ```Java``` 创造者做出的错误设计决定。 例如，更好的名称应该是 ```FatalException```。

错误定义了由于某种原因函数执行失败的情况。 错误的典型示例是找不到文件错误、向远程服务发送 ```HTTP``` 请求时出错或无法解析配置文件。 假设一个函数可以抛出错误。 根据错误，函数调用者可以决定如何处理错误。 如果出现暂时性错误，例如网络请求失败，函数调用者可以稍等片刻，然后再次调用该函数。 或者，函数调用者可以使用默认值。 例如，如果一个函数试图加载一个不存在的配置文件，它可以使用一些默认配置来代替。 在某些情况下，函数调用者只能不处理错误或捕获错误但在更高的抽象级别上抛出另一个错误。 假设一个函数试图加载一个配置文件，但是加载失败，并且不存在默认配置。 在那种情况下，该函数只能将错误传递给它的调用者。 最终，这个错误在调用堆栈中冒泡，整个过程由于无法加载配置而终止。 这是因为运行应用程序需要配置。 如果没有配置，应用程序只能退出。

定义错误类时，为你的软件组件定义一个基本错误类。 例如，对于数据导出器微服务，定义一个 ```DataExporterError``` 基错误类。 对于每个可以抛出异常的函数，在与该函数相同的抽象级别定义一个基本错误类。 该错误类应该扩展软件组件的基本错误类。 例如，如果你在 ```ConfigParser``` 类中有一个 ```parse(configStr)``` 函数，请为该函数定义一个名为 ```ConfigParseError``` 的基本错误类。 如果你有一个 ```readFile``` 函数，请定义一个名为 ```FileReadError``` 的基本错误类。 如果你有一个所有方法都可能引发错误的类，那么最好在类级别定义一个基本错误类。 例如，如果你有一个带有抛出方法的 ```UserService``` 类，你可以指定一个 ```UserServiceError``` 类并从 ```UserService``` 类方法中抛出该类的错误。

下面是为数据导出器微服务定义的错误示例：

```java
public class DataExporterError extends RuntimeException {
  public DataExporterError(final String message) {
    super(message);
  }
}

public class FileReadError extends DataExporterError {
  public FileReadError(final String message) {
    super(message);
  }
}

public class ConfigParseError extends DataExporterError {
  public ConfigParseError(final String message) {
    super(message);
  }
}
```

遵循前面的规则可以很容易地捕获代码中的错误，因为你可以从被调用的方法（或类）名称中推断出错误类名称。 在下面的示例中，我们可以从 ```readFile``` 方法名称推断出 ```FileReadError``` 错误类名称：

```java
try {
  final String fileContents = fileReader.readFile(...);
} catch (final FileReadError error) {
  // Handle error
}
```

你还可以在 ```catch``` 子句中使用软件组件的基本错误类来捕获所有用户定义的错误。 下面两个例子的效果是一样的。

```java
try {
  final String configFileContents = fileReader.readFile(...);
  return configParser.parse(configFileContents);
} catch (final FileReadError | ConfigParseError error) {
  // Handle error situation
}
```

```java
try {
  final String configFileContents = fileReader.readFile(...);
  return configParser.parse(configFileContents);
} catch (final DataExporterError error) {
  // Handle error situation
}
```

不要捕获该语言的基础异常类或其他一些过于通用的异常类，因为除了所有用户定义的错误之外，它们还会捕获异常，例如空指针异常，这可能不是你想要的。 所以，不要像这样捕获过于通用的异常类：

```java
try {
  final String configFileContents = fileReader.readFile(...);
  return configParser.parse(configFileContents);
} catch (final Exception exception) {
  // Do not use! Catches all exceptions
}
```

另外，不要捕获 ```Java``` 中的 ```Throwable``` 类，因为它也会捕获任何不应该被捕获的致命错误：

```java
try {
  final String configFileContents = fileReader.readFile(...);
  return configParser.parse(configFileContents);
} catch (final Throwable throwable) {
  // Do not use! Catches everything including
  // all exceptions and fatal errors
}
```

仅在代码中的特殊位置捕获所有异常，如在主函数或主循环中，如处理 ```HTTP``` 请求的 ```Web``` 服务中的循环或线程的主循环。 下面是在 ```main``` 函数中正确捕获该语言的异常基类的示例。 当你在 ```main``` 函数中捕获到不可恢复的异常时，记录它并使用适当的错误代码退出进程。 当你在主循环中发现不可恢复的错误时，将其记录下来并在可能的情况下继续循环。

```java
public static void main(final String[] args) {
  // ...

   try {
     dataExporter.run(...);
   } catch (final Exception exception) {
     logger.log(exception);
     System.exit(1);
   }
}
```

如果需要，你还可以让你的软件组件抛出异常。 在下面的示例中，我们为数据导出器微服务创建了一个异常基类，并从中派生了一个特定的异常：

```java
public class DataExporterException extends RuntimeException {
  public DataExporterException(final String message) {
    super(message);
  }
}

public class MySpecificException extends DataExporterException {
  public MySpecificException(final String message) {
    super(message);
  }
}
```

使用上述规则，你可以使你的代码面向未来或向前兼容，以便将来可以添加从函数中抛出的新错误。 假设你正在使用这样的 ```fetchConfig``` 函数：

```java
try {
  final var configuration = configFetcher.fetchConfig(configUrl);
} catch (final ConfigFetchError error) {
  // Handle error
}
```

如果 ```fetchConfig``` 函数抛出新类型的错误，你的代码应该仍然有效。 假设 ```fetchConfig``` 函数可能抛出以下新错误：

- 格式错误的网址错误
- 找不到服务器错误
- 连接超时错误

当实现这些新错误的类时，它们必须扩展函数的基本错误类，在本例中为 ```ConfigFetchError``` 类。 下面是定义的新错误类：

```java
public class MalformedConfigUrlError extends ConfigFetchError {
  public MalformedConfigUrlError(final String message) {
    super(message);
  }
}

public class ConfigServerNotFoundError extends ConfigFetchError {
  public ConfigServerNotFoundError(final String message) {
    super(message);
  }
}

public class ConfigFetchTimeoutError extends ConfigFetchError {
  public ConfigFetchTimeoutError(final String message) {
    super(message);
  }
}
```

你稍后可以增强你的代码并以不同方式处理从 ```fetchConfig``` 抛出的不同错误。 例如，你可能想要处理 ```ConfigFetchTimeoutError``` 以便函数等待一段时间然后重试操作，因为错误可能是暂时的：

```java
try {
  final var configuration = configFetcher.fetchConfig(configUrl);
} catch (final ConfigFetchTimeoutError error) {
  // Retry after a while
} catch (final MalformedConfigUrlError error) {
  // Inform caller that URL should be checked
} catch (final ConfigServerNotFoundError error) {
  // Inform caller that URL host/port cannot be reached
} catch (final ConfigFetchError error) {
  // Handle possible other error situations
  // This will catch any new exception that could be thrown
  // from the 'fetchConfig' function in the future
}
```

在上面的示例中，我们正确地处理了抛出的错误，但是你很容易忘记处理抛出的错误。 这是因为函数签名中没有任何内容告诉你函数是否可以抛出。 找出答案的唯一方法是查看文档（如果可用）或调查源代码（如果可用）。 这是关于错误处理的最大问题之一，因为你必须知道并记住函数可以抛出异常，并且你必须记住捕获和处理错误。 你并不总是想立即处理错误，但你仍然必须意识到错误会在调用堆栈中冒泡，最终应该在代码的某个地方处理。

这个问题的解决方案是让抛出错误更明确：

> 如果函数可以抛出错误，请在函数名称中使用```try```前缀。

这是一个简单的规则。 如果一个函数可以抛出错误，那么命名该函数使其名称以 ```try``` 开头。 这让每个调用者都清楚该函数可能会抛出错误，并且调用者应该为此做好准备。 对于函数的调用者，有三种方法可以处理抛出的错误：

1. 捕获被调用函数（或类或软件组件）的基本错误类并处理错误，例如，如果你正在调用名为 ```tryFetchData``` 的函数，则捕获 ```DataFetchError```。
2. 捕获被调用函数（或类或软件组件）的基本错误类，并在更高的抽象层次上抛出新错误。 现在你还必须使用 try 前缀命名调用函数。
3. 不要捕获错误。 让它们在调用堆栈中向上传播。 现在你还必须使用 ```try``` 前缀命名调用函数。

这是备选方案 1 的示例：

```java
public class ConfigFetcher {
  public Configuration fetchConfig(final String configUrl) {
    try {
      final var configDataStr = dataFetcher.tryFetchData(configUrl);
      return configParser.tryParse(configDataStr);
    } catch (final DataFetchError | ConfigParseError error) {
      // You could also catch DataFetchError and 
      // ConfigParseError in different catch clauses
      // if their handling differs
      // You could also catch the base error class DataExporterError 
      // of the software component 
    }
  }
}
```

这是备选方案 2 的示例：

```java
public class ConfigFetcher {
  public Configuration tryFetchConfig(final String configUrl) {
    try {
      final var configDataStr = dataFetcher.tryFetchData(configUrl); 
      return configParser.tryParse(configDataStr);
    } catch (final DataFetchError | ConfigParseError error) {
      // Error on higher level of abstraction is thrown
      // This function must be named with the 'try' prefix
      // to indicate that it can throw
      throw new ConfigFetchError(...);
    }
  }
}

public class DataExporter {
  public void initialize(...) {
    try {
      final var configuration = configFetcher.tryFetchConfig(...);
    } catch (final ConfigFetchError error) {
      // Handle error
    }
  }
}
```

这是备选方案 3 的示例：

```java
public class ConfigFetcher {
  public Configuration tryFetchConfig(final String configUrl) {
    final var configDataStr = dataFetcher.tryFetchData(configUrl);
    return configParser.tryParse(configDataStr);
      
    // No try-catch, all thrown errors from both tryFetchData
    // and tryParseConfiguration function calls propagate
    // to the caller and 
    // this function must be named with the 'try' prefix
    // to indicate that it can throw
  }
}

public class DataExporter {
  public void initialize(...) {
    try {
      final var configuration = configFetcher.tryFetchConfig(...);
    } catch (final DataExporterError error) {
      // In this case you must catch the base error class of
      // the software component (DataExporterError), because
      // you don't know what errors tryFetchConfig can
      // throw, because no ConfigFetchError class
      // has been defined
    }
  }
}
```

作为旁注，可以开发一个强制正确命名抛出函数的 ```linting``` 规则。 如果函数抛出或传播错误，该规则应强制函数名称具有 ```try``` 前缀。 当函数在 ```try-catch``` 块外调用抛出（```try``` 前缀）方法时，它会传播错误。

你还可以创建一个包含 ```try``` 前缀函数的库，这些函数包装不遵循 ```try``` 前缀规则的抛出函数：

```JsonParser.js```

```js
export default class JsonParser {
  static tryParse(json, reviver) {
    return JSON.parse(json, reviver);
  }
}
```

使用 ```Web``` 框架时，框架通常会提供错误处理机制。 框架捕获错误并将其映射到 ```HTTP``` 响应，并使用 ```HTTP``` 状态代码指示失败。 通常默认状态代码是 ```500 Internal Server Error```。 例如，当使用 ```Spring Boot``` 时，你可以使用 ```@ResponseStatus``` 注释标记你的自定义错误类：

```java
@ResponseStatus(HttpStatus.BAD_REQUEST)
class MyError extends RuntimeException {
  // ...
}
```

在 ```Spring``` 框架中，还有其他方法可以将错误映射到 ```HTTP``` 响应。

当你使用 ```Web``` 框架的错误处理机制时，使用 ```try``` 前缀命名抛出函数没有任何好处。 你可以选择退出 ```try-prefix``` 规则。

在软件组件文档中记录所使用的错误处理机制通常是一种很好的做法。

### 在 ```Java``` 中处理检查异常

在定义软件组件的错误时，你可以在 ```Java``` 中使用检查异常。 使用已检查的异常可以帮助你记住处理错误或让它们在调用堆栈中向上传播。

使用 ```Java``` 的已检查异常时，定义软件组件的基本错误类以扩展 ```Exception``` 类而不是 ```RuntimeException``` 类。 当一个函数抛出一个```checked exception```时，没有必要在函数名前加上```try```前缀。 下面是定义检查异常的示例：

```java
public class DataExporterError extends Exception {
  public DataExporterError(final String message) {
    super(message);
  }
}

public class DataFetchError extends DataExporterError {
  public DataFetchError(final String message) {
    super(message);
  }
}

public class ConfigParseError extends DataExporterError {
  public ConfigParseError(final String message) {
    super(message);
  }
}

public class InitializationError extends DataExporterError {
  public InitializationError(final String message) {
    super(message);
  }
}

public class DataFetcher {
  public String fetchData(...) 
  throws DataFetchError {
    // ...
  }
}

public class ConfigParser {
  public Configuration parse(...) 
  throws ConfigParseError {
    // ...
  }
}

public class DataExporter {
  public void initialize(...) throws InitializationError {
    try {
      final var configDataStr = dataFetcher.fetchData(configUrl);
      final var configuration = configParser.parse(configDataStr);
       
      // ...
    } catch (final DataFetchError | ConfigParseError error) {
      throw new InitializationError(error);
    }
  }
}
```

稍后，可以修改解析函数的实现以抛出从 ```ConfigParseError``` 类派生的其他错误。 这种更改不需要修改代码库的其他部分。

在更高级别的软件组件代码上，你还可以在 ```throws``` 子句中使用软件组件的基本错误类在调用堆栈中向上传播错误：

```java
public class DataExporter {
  public void initialize(...) throws DataExporterError {
    final var configDataStr = dataFetcher.fetchData(configUrl);
    final var configuration = configParser.parse(configDataStr);  
            
    // ...
  }
}
```

### 返回错误

作为抛出错误的替代方法，可以使用返回值将错误行为传达给函数调用者。 使用异常处理机制比返回错误有一些优势。 当函数可以返回错误时，你必须始终在函数调用后立即检查错误。 这会导致代码包含嵌套的 ```if``` 语句，从而影响代码的可读性。 异常处理机制允许你将错误传播到调用堆栈中的更高级别。 你还可以执行多个可能在单个 ```try``` 块内失败的函数调用，并在 ```catch``` 块中提供单个错误处理程序。 有些语言不提供异常处理机制，这意味着你必须从函数中返回错误。 在 ```C++``` 等语言中，你可以通过返回错误值或指示符而不是抛出异常来优化关键任务代码。

#### 返回失败指示器

当函数不需要返回任何附加值时，你可以从可失败函数返回失败指示符。 当不需要返回任何特定的错误代码或消息时，从函数返回一个失败指示符就足够了。 这可能是因为函数失败的原因只有一个，或者函数调用者对错误细节不感兴趣。 要返回失败指示符，请从函数返回一个布尔值：```true``` 表示操作成功，```false``` 表示失败：

```java
bool performTask(...) 
{
  bool taskWasPerformed;
  
  // Perform the task and set the value of 'taskWasPerformed' 
  
  return taskWasPerformed;
}
```

#### 返回可选值
假设一个函数应该返回一个值，但是函数调用可能会失败，而函数调用失败的原因恰恰是一个。 在这种情况下，从函数返回一个可选值。 在下面的示例中，只有当缓存中没有存储特定键的值时，从缓存中获取值才会失败。 我们不需要返回任何错误代码或消息。

```Cache.java```

```java
public interface Cache<K, V> {
  void add(K key, V value);
  Optional<V> get(K key);
}
```

#### 返回错误对象
当你需要向函数调用者提供有关错误的详细信息时，你可以从函数返回一个错误对象：

```BackendError.ts```

```javascript
export type BackendError = {
  statusCode: number;
  errorCode: number;
  message: string;
};
```

如果函数不返回任何值但会产生错误，则可以在将 ```null``` 定义为不同类型且语言支持类型联合（例如 ```TypeScript```）的语言中返回错误对象或 ```null```：

```DataStore.ts```

```javascript
export interface DataStore {
  updateEntity<T extends Entity>(...):
    Promise<BackendError | null>;
}
```

或者，返回可选错误。 下面是 ```Java``` 中的示例：

```java
import lombok.experimental.Value;

@Value
public class BackendError {
  int statusCode;
  int errorCode;
  String message;
}

public interface DataStore {
  <T extends Entity> Optional<BackendError> updateEntity(...);
}
```

假设一个函数需要返回一个值或一个错误。 在这种情况下，你可以使用 2 元组（即一对）类型，其中元组中的第一个值是实际值或出现错误时为 ```null```，元组中的第二个值是错误对象或 ```null``` 操作成功时的值。 以下是 ```TypeScript``` 和 ```Java``` 中的示例。 在 ```Java``` 示例中，你当然需要返回可选值而不是空值。

```DataStore.ts```

```javascript
export class DataStore {
  createEntity<T extends Entity>(...):
    Promise<[T, null] | [null, BackendError]>;
}
```

```DataStore.java```

```java
import org.javatuples.Pair;

public interface DataStore {
  <T extends Entity> Pair<Optional<T>, Optional<BackendError>>
  createEntity(...);
}
```

上面的```Java```例子使用起来比较麻烦，而且类型定义看起来很长。 我们应该在这里使用 ```Either``` 类型，但 ```Java``` 没有。 两种类型都包含两个值之一，即左值或右值。 左边的值是函数运行成功时返回的值，右边的值是错误。 ```Either``` 类型可以定义如下：

```Either.java```

```java
public class Either<L, R>
{
  private final Optional<L> maybeLeftValue;
  private final Optional<R> maybeRightValue;
  
  private Either(
    final Optional<L> maybeLeftValue,
    final Optional<R> maybeRightValue
  ) {
    this.maybeLeftValue = maybeLeftValue;
    this.maybeRightValue = maybeRightValue;
  }
  
  public static <L, R> Either<L, R> withLeft(
    final L value
  ) {
    return new Either<>(Optional.of(value), Optional.empty());
  }
  
  public static <L, R> Either<L, R> withRight(
    final R value
  ) {
    return new Either<>(Optional.empty(), Optional.of(value));
  }

  public boolean hasLeftValue() {
    return maybeLeftValue.isPresent();
  }

  public <T> Either<T, R> mapLeft(
    Function<? super L, ? extends T> mapper
  ) {
    return new Either<>(maybeLeftValue.map(mapper),
                        maybeRightValue);
  }

  public <T> Either<L, T> mapRight(
    Function<? super R, ? extends T> mapper)
  {
      return new Either<>(maybeLeftValue,
                          maybeRightValue.map(mapper));
  }
  
  public <T> T map(
    Function<? super L, ? extends T> leftValueMapper,
    Function<? super R, ? extends T> rightValueMapper)
  {
    return maybeLeftValue.<T>map(leftValueMapper)
      .orElseGet(() -> 
        maybeRightValue.map(rightValueMapper).get());
  }
  
  public void apply(
    Consumer<? super L> leftValueConsumer,
    Consumer<? super R> rightValueConsumer
  ) {
    maybeLeftValue.ifPresent(leftValueConsumer);
    maybeRightValue.ifPresent(rightValueConsumer);
  }
}
```

现在我们可以使用新的 ```Either``` 类型并重写示例如下：

```DataStore.java```

```java
public interface DataStore {
  <T extends Entity> Either<T, BackendError> createEntity(...);
}
```

#### 适应想要的错误处理机制
你可以通过创建适配器方法来适应所需的错误处理机制。 例如，如果一个库有一个 ```throwing``` 方法，你可以创建一个适配器方法返回一个可选值或错误对象。 下面是一个 ```VInt``` 类中的 ```tryCreate``` 工厂方法，它可以抛出：

```VInt.ts```

```typescript
class VInt {
  // ...

  private constructor(...) {
    // ...
  }

  // this will throw if invalid 'value' is given
  // that doesn't match the 'validationSpec'
  static tryCreate<VSpec extends string>(
    validationSpec: IntValidationSpec<VSpec>,
    value: number
  ): VInt<VSpec> | never {
    // constructor can throw
    return new VInt(validationSpec, value);
  }

  // ...
}
```

我们可以为 ```VInt``` 类中的 ```tryCreate``` 工厂方法创建一个带有适配器方法的 ```VIntFactory``` 类。 ```VIntFactory``` 类提供了一个非抛出的创建方法：

```VIntFactory.ts```

```typescript
class VIntFactory {
  static create<VSpec extends string>(
    validationSpec: IntValidationSpec<VSpec>,
    value: number
  ): VInt<VSpec> | null {
    try {
      return VInt.tryCreate(validationSpec, value);
    } catch {
      return null;
    }
  }
}
```

我们还可以创建一个不抛出但返回值或错误的方法：

```VIntFactory.ts```

```typescript
class VIntFactory {
  static createOrError<VSpec extends string>(
    validationSpec: IntValidationSpec<VSpec>,
    value: number
  ): [VInt<VSpec>, null] | [null, Error] {
    try {
      return [VInt.tryCreate(validationSpec, value), null];
    } catch (error) {
      return [null, error as Error];
    }
  }
}
```

我们还可以为 ```TypeScript``` 引入一个简化版本的 ```Either``` 类型：

```Either.ts```

```typescript
export type Either<L, R> = [L, null] | [null, R];
```

现在我们可以像这样重写上面的例子：

```VIntFactory.ts```

```typescript
class VIntFactory {
  static createOrError<VSpec extends string>(
    validationSpec: IntValidationSpec<VSpec>,
    value: number
  ): Either<VInt<VSpec>, Error> {
    try {
      return [VInt.tryCreate(validationSpec, value), null];
    } catch (error) {
      return [null, error as Error];
    }
  }
}
```

#### 异步函数错误处理
异步函数是通常会失败的函数。 它们经常执行 ```I/O``` 操作，如文件或网络 ```I/O```。 对于可失败的异步操作，你必须记住处理失败案例。 出于这个原因，建议使用可以抛出的函数名称中使用的相同 ```try``` 前缀来命名可失败的异步操作。 下面是两个在 ```JavaScript/TypeScript``` 中处理异步操作失败的例子：

```typescript
tryMakeHttpRequest(url).then((value) => {
  // success
}, (error) => {
  // Handle error
});
tryMakeHttpRequest(url).then((value) => {
  // success
}).error((error) => {
  // Handle error
});
```

从上面的例子可以看出，很容易忘记添加错误处理。 如果 ```Promise``` 类中有一个 ```thenOrCatch``` 方法可以接受以下类型的回调，那就更好了：

```typescript
tryMakeHttpRequest(url).thenOrCatch(([value, error]) => {
  // Now it is harder to forget to handle an error
  // Check 'error' before using the 'value'
});
```

你可以使异步函数调用同步。 在 ```JavaScript/TypeScript``` 中，这可以使用 ```async``` 和 ```await``` 关键字来完成。 一个失败的异步操作使同步可以抛出。 下面是与上面同步的相同示例：

```typescript
async function fetchData() {
  try {
    await tryMakeHttpRequest(url);
  } catch {
    // Handle error
  }
}
```

#### 功能异常处理
下面的 ```Failable<T>``` 类可用于功能性错误处理。 ```Failable<T>``` 对象表示类型 T 的值或 ```RuntimeException``` 类的实例。

```Failable.java```

```java
public class Failable<T> {
  private final Either<T, RuntimeException> valueOrError;

  private Failable(
    final Either<T, RuntimeException> valueOrError
  ) {
    this.valueOrError = valueOrError;
  }

  public static <T> Failable<T> withValue(
    final T value
  ) {
    return new Failable<>(Either.withLeft(value));
  }

  public static <T> Failable<T> withError(
    final RuntimeException error
  ) {
    return new Failable<>(Either.withRight(error));
  }

  public T orThrow(
    final Class<? extends RuntimeException> ErrorClass
  ) {
    return valueOrError.map(
      (value) -> value,
      (error) -> {
          try {
            throw (RuntimeException)ErrorClass
              .getConstructor(String.class)
              .newInstance(error.getMessage());
          } catch (InvocationTargetException |
                   InstantiationException |
                   IllegalAccessException |
                   IllegalArgumentException | 
                   NoSuchMethodException exception) {
            throw new RuntimeException(exception);
          }
      });
  }

  public T orElse(final T otherValue) {
    return valueOrError.map(value -> value,
                            error -> otherValue);
  }

  public <U> Failable<U> mapValue(
    final Function<? super T, ? extends U> mapper
  ) {
    return new Failable<>(valueOrError.mapLeft(mapper));
  }

  public Failable<T> mapError(
    final Function<? super RuntimeException,
                   ? extends RuntimeException> mapper
  ) {
    if (valueOrError.hasLeftValue()) {
      final var error = 
        new RuntimeException(mapper
          .apply(new RuntimeException(""))
          .getMessage());

      return Failable.withError(error);
    } else {
      return new Failable<>(valueOrError.mapRight(mapper));
    }
  }
}
```

在下面的示例中，```readConfig``` 方法返回一个 ```Failable<Configuration>```。 ```tryInitialize``` 函数要么获取 ```Configuration``` 的实例，要么抛出 ```InitializationError``` 类型的错误。

```java
public void tryInitialize() {
  final var configuration = configReader
    .readConfig(...)
    .orThrow(InitializationError.class);
}
```

上述功能方法的好处是它比整个 ```try-catch``` 块更短。 上面的函数式方法也和 ```try-catch``` 块一样容易理解。 请记住，你应该编写最短、最易理解的代码。 当方法返回可失败对象时，你不必使用 ```try``` 前缀命名该方法，因为该方法不会抛出。

你还可以使用 ```Failable``` 类的其他方法。 例如，可以使用 ```orElse``` 方法返回默认值：

```java
public void initialize() {
  final var configuration = configReader
    .readConfig(...)
    .orElse(new DefaultConfiguration());
}
```

你还可以将多个命令式可失败语句转换为功能性可失败语句。 例如，而不是写：

```java
public void tryInitialize() {
  try {
    final var configDataStr = dataFetcher.tryFetchData(configUrl); 
    final var configuration = configParser.tryParse(configDataStr);
  } catch (final DataExporterError error) {
    throw new InitializationError(error.getMessage());
  }
}
```

你可以写：

```java
public void tryInitialize() {
  try {
    final var configuration = dataFetcher
      .fetchData(configUrl)
      .mapValue(configParser::parse)
      .orThrow(InitializationError.class);
}
```

将可失败的命令式代码与函数式编程结构一起使用很容易出错。 假设我们有以下 ```TypeScript``` 代码，可以读取多个配置文件并将其解析为单个配置对象：

```javascript
configFilePathNames
  .reduce((accumulatedConfig, configFilePathName) => {
    const configJson = fs.readFileSync(configFilePathName, 'utf-8');
    const configuration = JSON.parse(configJson);
    return { ...accumulatedConfig, ...configuration };
}, {});
```

在上面的示例中，很容易忘记处理错误，因为 ```reduce``` 函数的可抛性取决于提供的回调函数。 我们不能在上面的例子中的任何地方使用 ```try-prefix```。 我们可以做的是：

```javascript
function tryReadConfig(
  accumulatedConfig: Record<string, unknown>,
  configFilePathName: string
) {
  const configJson = fs.readFileSync(configFilePathName, 'utf-8');
  const configuration = JSON.parse(configJson);
  return { ...accumulatedConfig, ...configuration };
}

export function getConfig(
  configFilePathNames: string[]
): Record<string, unknown> {
  try {
    return configFilePathNames.reduce(tryReadConfig, {});
  } catch (error) {
    // ...
  }
}
```

我们现在添加了 ```try-prefix```，但代码可以更好地阅读。 更好的替代方法是使用函数式编程构造 ```Failable<T>``` 来返回可失败的配置。 ```TypeScript``` 中的 ```Failable<T>``` 类实现这里就不介绍了，但是可以类似 ```Java``` 实现。 下面是使用 ```Failable<T>``` 类的示例：

```java
function accumulatedConfigOrError(
  accumulatedConfigOrError: Failable<Record<string, unknown>>,
  configFilePathName: string
): Failable<Record<string, unknown>> {
  try {
    const configJson = fs.readFileSync(configFilePathName, 'utf-8');
    const config = JSON.parse(configJson);
    
    return accumulatedConfigOrError.mapValue(accumulatedConfig =>
      ({ ...accumulatedConfig, ...config }));
  } catch (error: any) {
    return accumulatedConfigOrError.mapError(accumulatedError =>
      new Error(`${accumulatedError.message}\n${error.message}`)
    );
  }
}

export function getConfig(
  configFilePathNames: string[]
): Failable<Record<string, unknown>> {
  return configFilePathNames.reduce(
    accumulatedConfigOrError,
    Failable.withValue({})
  );
}
```

#### 流错误处理
处理流的错误也是很容易被遗忘的事情。 流通常用于可能失败的 ```I/O``` 操作。 你应该为使用流时的错误处理做好准备。 在 ```JavaScript/TypeScript``` 中，可以使用流的 ```on``` 方法按以下方式注册流的错误处理程序：```stream.on('error', () => { ... })```。

下面是使用流的示例：

```javascript
// ...

const writeStream = fs.createWriteStream(filePathName);
    
this.writeStream.on('error', (error) => {
   // Handle errors
});

writeStream.write(...);
// More writes...

writeStream.close();
```

我们如何改善流的开发人员体验，以便不忘记错误处理？ 一种解决方案是向流工厂方法添加错误处理程序回调参数。 出现错误时将调用此回调。 如果不需要错误处理，可以为回调提供空值。 这样，创建流的开发人员就不会忘记提供错误处理函数。

## 不要传递或返回空原则

此原则适用于 ```Java``` 和 ```C++``` 等不将空值实现为单独类型的语言。 当 ```strictNullChecks``` 配置参数设置为 ```true``` 时，```TypeScript``` 将 ```null``` 实现为不同的类型，你应该始终将其设置为 ```true```。 所以，这个原则不适用于 ```TypeScript```。

空值是英国计算机科学家 Tony Hoare 的错误发明，他将空引用的发明称为"十亿美元的错误"。 原因很明显，因为我们都曾这样做过：忘记处理空值。 当我们不处理空值时，我们将它传递给其他永远不会用空值调用的函数。 最终，这将导致代码某处抛出空值异常。

当你从函数返回值时，永远不要返回空值。 你应该返回一个可选值。 在下面的示例中，我们为映射中的键返回一个可选值，因为映射中没有与特定键关联的值。

```java
/ BAD!
public class Map<K, V> {
  public V get(final K key) {
    if (...) {
      // ...
    } else {
      return null;
    }
  }
}


// GOOD!
public class Map<K, V> {
  public Optional<V> get(final K key) {
    // ...
  }
}
```

将参数传递给函数时，切勿传递空值。 被调用函数通常从不期望用空参数调用。 假设一个函数需要一个可以丢失的参数。 在这种情况下，该函数可以为该参数定义一个默认值（在 ```C++``` 和 ```JavaScript/TypeScript``` 中可能，但在 ```Java``` 中不行），或者可以在可选参数不存在的地方定义一个重载函数。 也可以定义函数，使参数具有可选类型，但你应该更喜欢可选参数或函数的重载版本。

## 避免差一错误原则

差一错误通常是由于编程语言中的集合是使用从零开始的索引来索引的。 从零开始的索引对于人类来说是不自然的，但对于计算机来说却是极好的。 但是，编程语言在设计时应考虑到人性。 人们从不谈论获取数组的第零个值。 我们谈到获取数组中的第一个值。 由于 ```null``` 值被称为十亿美元的错误，我将把基于零的索引称为另一个十亿美元的错误。 让我们希望有一天我们能得到一种基于 ```one``` 的索引的编程语言！ 但是我们必须忘掉从零开始的索引习惯……那是另一个问题。

下面是两个 ```JavaScript``` 编程错误的例子，如果你不够小心，很容易犯这些错误：

```javascript
for (let index = 0; index <= array.length; index++) {
  // ...
}

for (let index = 0; index < array.length - 1; index++) {
  // ...
}
```

在第一个例子中，应该有```<```而不是```<=```，在后一个例子中，应该有```<=```而不是```<```。 幸运的是，使用现代编程语言结构（如 ```Java``` 的增强型 ```for``` 循环或 ```C++``` 的基于范围的 ```for``` 循环或函数式编程）可以避免上述错误。

下面是在 ```Java``` 中避免差一错误的两个示例：

```java
for (final var value : values) {
  // ...
}

values.stream().forEach(value -> ...);
```

一些语言，如 ```JavaScript```，提供了一种访问数组最后一个元素的好方法。 除了写 ```array[array.length - 1]```，你可以写 ```array.at(-1)```。 同样，```array[array.length - 2]``` 与 ```array.at(-2)``` 相同。 你可以认为负索引是从数组末尾开始的基于 ```1``` 的索引。

让我们考虑一下 ```JavaScript``` 的 ```slice``` 方法的描述：

```slice()``` 方法将数组的一部分的浅表副本返回到从开始索引到结束索引（不包括结束）选择的新数组对象中。

这里的问题是"不包含结尾"部分。 很多人，默认情况下，认为如果给定一个范围，它就是包含的，但是在 ```slice``` 方法的情况下，它在开始时是包含的，在结束时是不包含的：```[start, end[```. 这种违背第一假设的函数定义很容易造成差一错误。 如果 ```slice``` 方法默认使用包含范围 ```[start, end]``` 会更好。

此外，单元测试是你尝试发现差一错误时的好帮手。 因此，请记住也为边缘情况编写单元测试。

## 谷歌搜索原则时要批判
> 你应该始终分析从网络上获取的代码，看看它是否符合生产代码的标准。

我们都做过，而且做过数百次：用谷歌搜索答案。 通常，你可以通过谷歌搜索找到好的资源，但问题通常是谷歌搜索结果中的示例不一定是产品质量。 其中缺少的一件事是错误处理。 如果你从网站复制和粘贴代码，则可能无法正确处理错误。 你应该始终分析复制粘贴的代码以查看是否需要添加错误处理。

当你为其他人提供答案时，请尝试使代码尽可能接近生产环境。 在 Stack Overflow 中，你会在问题下方找到投票最多的答案。 如果答案缺少错误处理，你可以对此发表评论并让作者改进他们的答案。 你还可以对似乎最适合生产的答案进行投票。 通常，投票最多的答案已经很老了。 出于这个原因，向下滚动以查看是否有更现代的解决方案更适合你的需求是很有用的。 你还可以对更现代的解决方案进行投票，以便它在答案列表中的排名更高。

关于开源库，其文档中的第一个示例只能描述"happy path"的使用场景，错误处理仅在文档的后面部分描述。 如果你从"happy path"示例中复制粘贴代码而忘记添加错误处理，这可能会导致问题。 出于这个原因，开源库作者应该在文档的早期提供生产质量的示例。

## 优化原则

> 避免过早优化。 过早的优化可能会阻碍为软件组件设计合适的面向对象设计。 首先测量未优化的性能。 然后决定是否需要优化。 逐一实施优化并在每一轮优化后测量性能以确定优化是否重要。 然后，你可以在未来的项目中利用获得的知识来进行优化，以提供足够显着的性能提升。 有时，如果你知道需要进行特定的优化（例如，根据以前的经验）并且可以在不对面向对象设计产生负面影响的情况下实施优化，那么你可以在项目的早期阶段进行性能优化。

### 优化模式

本节介绍以下优化模式：

- 优化仅忙循环模式
- 删除不必要的功能模式
- 以块模式复制内存 (```C++```)
- 对象池模式
- 用非虚拟方法模式替换虚拟方法 (```C++```)
- 内联方法模式 (```C++```)
- 使用唯一指针模式 (```C++```)
- 共享相同的对象 ```a.k.a``` ```flyweight``` 模式

#### 仅优化忙循环模式
优化应该主要只针对软件组件中的一个或多个繁忙循环。 繁忙循环是线程中反复执行的循环，每秒可能执行数千次或更多次迭代。 性能优化不应针对在软件组件的生命周期中只执行一次或几次的功能，并且运行该功能不会花费很长时间。 例如，应用程序在启动时可以具有配置读取和解析功能。 此功能需要很短的时间才能执行。 优化该功能是不合理的，因为它只运行一次。 你能不能在 200 或 300 毫秒内读取和解析配置并不重要，即使性能上有 50% 的差异。

让我们以数据导出器微服务为例。 我们的数据导出器微服务由输入、转换器和输出部分组成。 输入部分从数据源读取消息。 如果我们为此目的使用第 3 方库，我们不会影响消息阅读部分。 当然，如果有多个 3rd 方库可用，则可以设计性能测试并评估哪个 3rd 方库提供最佳性能。 如果有多个 3rd 方库可用于相同的功能，我们倾向于使用最流行的库或我们事先知道的库。 如果性能是一个问题，我们应该评估不同的库并比较它们的性能。

数据导出器微服务在其繁忙的循环中具有以下功能：将输入消息解码为内部消息、执行转换以及对输出消息进行编码。 解码输入消息需要解码消息中的每个字段。 假设每秒处理 5000 条消息，每条消息有 100 个字段。 在一秒钟内，必须解码 50000 个字段。 这表明解码功能的优化至关重要。 这同样适用于输出消息编码。 我们诺基亚自己实现了 ```Avro``` 二进制字段的解码和编码。 我们能够使它们比第 3 方库提供的更快。

#### 删除不必要的功能模式
删除不必要的功能可以提高性能。 你应该停止批判性地思考你的软件组件：考虑到所有情况，我的软件组件是否只做必要的事情？

让我们考虑数据导出器的功能。 它当前正在将输入消息解码为内部消息。 在对数据进行各种转换时使用此内部消息。 转换后的数据被编码为所需的输出格式。 最终输出消息的内容可以是原始输入消息的一小部分。 这意味着只使用了解码消息的一小部分。 在这种情况下，如果只有 10% 的字段用于转换和输出消息，则无需解码输入消息的所有字段。 通过删除不必要的解码，我们可以提高数据导出器微服务的性能。

#### 以块模式复制内存 (```C++```)
如果你有一个连续的内存块，使用 ```memcpy``` 复制它。 不要在 for 循环中逐字节复制内存。 ```memcpy``` 函数的实现由 ```C++``` 编译器优化，以生成可最佳复制各种大小的内存块的机器代码。 例如，它可以在 64 位操作系统中将内存复制为 64 位值，而不是逐字节复制内存块。

在数据导出器微服务中，输入消息格式和输出消息格式可能相同，例如 ```Avro``` 二进制。 我们可能会遇到这样一种情况，```Avro``` 记录字段可以从输入消息复制到输出消息而无需任何转换。 在那种情况下，解码该记录字段是不必要的功能，我们可以跳过它。 我们要做的是复制一块内存。 一个 ```Avro``` 记录字段可以比较大，甚至 200 个字节由 40 个子字段组成。 我们现在可以跳过这 40 个子字段的解码和编码。 我们只需将 200 个字节从输入消息复制到输出消息。

#### 对象池模式

在 ```JavaScript``` 和 ```Java``` 等垃圾收集语言中，从垃圾收集的角度来看，使用对象池的好处是显而易见的。 在对象池模式中，对象只被创建一次，然后被重用。 这将减轻垃圾收集的压力。 如果我们不使用对象池，新对象可能会在繁忙的循环中重复创建，并且创建后不久就会被丢弃。 这会导致许多对象在短时间内可用于垃圾回收。 垃圾收集需要处理器时间，如果垃圾收集器有大量垃圾要收集，它可能会以未知的时间间隔使应用程序变慢一段未知的时间。

#### 用非虚拟方法模式替换虚拟方法 (```C++```)

如果你在繁忙的循环中使用大量对虚函数的调用，由于动态调度，在检查调用哪个虚方法时会有一些开销。 在 ```C++``` 中，这是使用虚拟表 (```vtables```) 完成的，虚拟表用于检查将调用哪个实际方法。 如果频繁调用虚拟方法，额外的 ```vtable``` 检查可能会对繁忙循环中的性能产生负面影响。 例如，数据导出器微服务的繁忙可以每秒调用 50000 次 ```Avro``` 二进制解码和编码函数。 我们可以通过将 ```Avro``` 二进制解码函数实现为非虚函数（如果之前声明为虚函数）来优化这些调用。 非虚函数不需要检查虚表，所以直接调用函数。

#### 内联方法模式 (```C++```)
假设你已经优化了使虚方法成为非虚方法。 如果方法很小，仍然可以进行另一种优化：内联方法。 内联方法意味着消除对该方法的调用，并将该方法的代码放置在对该方法进行调用的位置。 因此，内联后根本不需要调用该方法。 在数据导出器微服务中，我们将 ```Avro``` 二进制编码和解码函数设为非虚拟，现在我们可以将它们也内联以加速微服务。 但是，```C++``` 编译器可以决定内联函数是否真正内联。 我们不能 100% 确定函数是否内联。 这取决于编译器。 当我们使用 ```C++``` 的 ```inline``` 关键字将函数定义为内联函数时，我们只是向编译器提示该函数应该被内联。 只能内联非虚拟方法。 虚拟方法不能被内联，因为它们需要检查 ```vtable``` 来决定应该调用哪个方法。

#### 使用唯一指针模式 (```C++```)

如果你使用的是共享指针，则它们需要使共享指针的引用计数保持最新。 在繁忙的循环中，如果你使用共享指针，比如说每秒十万次，那么无论你使用共享指针还是唯一指针 (```std::unique_ptr```)，它都会开始显示出差异。 与原始指针相比，唯一指针几乎没有开销。 因此，在现代 ```C++``` 中不需要使用原始指针。 它不会在性能方面带来太多好处。 并且如果你使用裸指针，你必须记得自己释放与裸指针关联的已分配内存。 如果你不需要一个指向的对象被多个其他对象共享，你可以通过将共享指针更改为唯一指针来优化繁忙循环中的代码。 唯一指针始终只有一个所有者，多个对象不能共享它们。

#### 共享相同的对象 ```a.k.a``` 享元模式
如果你的应用程序有许多具有相同属性的对象，那么具有相同属性的对象的那些部分就是在浪费内存。 你应该将公共属性提取到一个新类中，并使原始对象引用该新类的共享对象。 现在你的对象共享一个公共对象，并且可能消耗更少的内存。 这种设计模式称为享元模式，在前面的章节中有更详细的描述。
